<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>书架</title>
    <url>/2020/01/01/life/%E4%B9%A6%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="2018年"><a href="#2018年" class="headerlink" title="2018年"></a>2018年</h1><h2 id="凯文·凯利三部曲"><a href="#凯文·凯利三部曲" class="headerlink" title="凯文·凯利三部曲"></a>凯文·凯利三部曲</h2><blockquote>
<p>刚开始步入大学生活的我，读的第一本关于时代发展的书《失控》。</p>
</blockquote>
<h3 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h3><h4 id="《失控》"><a href="#《失控》" class="headerlink" title="《失控》"></a>《失控》</h4><h2 id="《香农传》"><a href="#《香农传》" class="headerlink" title="《香农传》"></a>《香农传》</h2><h2 id="《信息简史》"><a href="#《信息简史》" class="headerlink" title="《信息简史》"></a>《信息简史》</h2><h2 id="《复利效应》"><a href="#《复利效应》" class="headerlink" title="《复利效应》"></a>《复利效应》</h2>]]></content>
      <categories>
        <category>历史记录</category>
      </categories>
      <tags>
        <tag>书架</tag>
      </tags>
  </entry>
  <entry>
    <title>替罪羊树学习笔记</title>
    <url>/2019/12/12/blog/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>一种基于部分重建的自平衡二叉搜索树。替罪羊树的主要思想就是将不平衡的树压成一个序列,然后暴力重构成一颗平衡的树。</p>
</blockquote>
<p>&emsp;&emsp;这里的平衡指的是：对于某个 <code>0.5&lt;=alpha&lt;=1</code>满足 <code>size( Lson(x) )&lt;=alpha*size(x) 并且 size( Rson(x) )&lt;=alpha*size(x)</code>,即这个节点的两棵子树的 size 都不超过以该节点为根的子树的 size，那么就称这个子树(或节点)是平衡的, alpha 最好不要选 0.5 ，容易T飞，一般选 0.75 就挺好的。而我就选择了0.8。<br>&emsp;&emsp;相较于splay这样选择维护平衡的操作，替罪羊树的维护就简单粗暴多了。</p>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ol>
<li>一个数一个值，相同的数也往左儿子那边放，至于为什么存在一个节点里，是因为暴力构树不好操作（二分）.</li>
</ol>
<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><pre><code>static int m;//操作次数
static double alp=0.8;//常量
static int mem[],pool=0;//垃圾回收数组和配套指针
static int val[];//节点数值
static int size[],tot[];
static int son[][];
static boolean real[];
static int root=0,cnt=0;
static int poi=0,cur[];
static int tob=0;</code></pre><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;通过重建树的方式让其他操作更加简单实现,常规操作跟splay差不多，核心在于重建树的代码，如把那些不存在的点更新去掉等。</p>
<h1 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

public class 替罪羊模板 {
    static int m;
    static double alp=0.8;
    static int mem[],pool=0;
    static int val[];
    static int size[],tot[];
    static int son[][];
    static boolean real[];
    static int root=0,cnt=0;
    static int poi=0,cur[];
    static int tob=0;
    public static void main(String[] args) throws IOException {
        Input in = new Input();StringBuilder sb = new StringBuilder();
        mem=new int[100001];
        for (int i =100000; i&gt;0; i--) mem[++pool]=i;
        m=in.nextInt();
        size=new int[m+2];tot=new int[m+2];
        son=new int[m+2][2];val=new int[m+2];
        cur=new int[m+2];real=new boolean[m+2];
        int pot,x;
        while(m--&gt;0) {
            pot=in.nextInt();x=in.nextInt();
            switch(pot){
            case 1:insert(0,1,root,x);if(isbad(root))rebuild(0,0,root);break;//删除
            case 2:del_val(x);break;//删除
            case 3:sb.append(get_rk(x)+&quot;\n&quot;);break;//某数的排名
            case 4:sb.append(get_kth(x)+&quot;\n&quot;);break;//排名第几位的数值
            case 5:sb.append(get_kth(get_rk(x)-1)+&quot;\n&quot;);break;//前驱
            case 6:sb.append(get_kth(get_rk(x+1))+&quot;\n&quot;);break;//后续
            }
        }
        System.out.println(sb);
    }
    public static int get_kth(int x) {//某个排名对应的值；
        int now=root;
        while(now&gt;0) {
            if(!real[now]&amp;&amp;(size[son[now][0]]+1==x)) {
                return val[now];
            }else if(size[son[now][0]]&gt;=x) {
                now=son[now][0];
            }else {
                x-=size[son[now][0]]+(real[now]?0:1);
                now=son[now][1];
            }
        }
        return 0;
    }
    public static void del_pos(int u,int y) {//删除标记某个数
        if(!real[u]&amp;&amp;(size[son[u][0]]+1==y)) {
            real[u]=true;size[u]--;return;
        }
        size[u]--;
        if(size[son[u][0]]+(real[u]?0:1)&gt;=y) {
            del_pos(son[u][0],y);
        }else {
            del_pos(son[u][1],y-(size[son[u][0]]+(real[u]?0:1)));
        }
    }
    public static int get_rk(int x) {//某个数的排名
        int now=root,ret=1;
        while(now!=0) {
            if(val[now]&gt;=x) {
                now=son[now][0];
            }else {
                ret+=size[son[now][0]]+(real[now]?0:1);
                now=son[now][1];
            }
        }
        return ret;
    }
    public static void del_val(int x) {//删除某个值
        del_pos(root,get_rk(x));
        if(1.0*tot[root]*alp&gt;size[root]) {
            rebuild(0,0,root);
        }
    }
    public static void insert(int fa,int d,int u,int x) {//插入节点
        if(u==0) {
            u=mem[pool--];val[u]=x;real[u]=false;
            tot[u]=1;size[u]=1;son[u][1]=0;son[u][0]=0;
            if(fa==0) {
                root=u;
            }else {
                son[fa][d]=u;
            }
            return;
        }
        tot[u]++;size[u]++;
        if(val[u]&gt;=x) {
            insert(u,0,son[u][0],x);
        }else { insert(u,1,son[u][1],x);}
        boolean flag=isbad(u);
        if(!flag&amp;&amp;tob&gt;0) { //通过有层次的递归判断是否需要重建树，减少运算
            if(son[u][0]==tob) {
                rebuild(u,0,son[u][0]);
            }else {
                rebuild(u,1,son[u][1]);
            }
            tob=0;
        }else if(flag) {
            tob=u;
        }
    }
    public static void rebuild(int fa,int d,int x) {//重建树
        poi=0;dfs(x);
        int mid=(1+poi)&gt;&gt;1;x=cur[mid];
        if(poi&gt;0)build(fa,d,x,1,poi);
        if(fa==0) {
            root=x;
        }else {
            son[fa][d]=x;
        }
    }
    public static boolean isbad(int x) {//是不是不平衡
        if(1.0*size[x]*alp&lt;=(double)Math.max(size[son[x][1]],size[son[x][0]]))return true;
        return false;
    }
    public static void dfs(int x) {//中序遍历存节点
        if(x==0)return;
        dfs(son[x][0]);
        if(!real[x]) {
            cur[++poi]=x;
        }else {
            mem[++pool]=x;
        }
        dfs(son[x][1]);
    }
    public static void build(int fa,int d,int x,int L,int R) {//二分建树
        int mid=(L+R)&gt;&gt;1;x=cur[mid];
        if(L==R) {
            son[x][0]=0;son[x][1]=0;
            size[x]=1;tot[x]=1;return;
        }
        if(L&lt;mid){
            son[x][0]=cur[(L+mid-1)&gt;&gt;1];
            build(x,0,son[x][0],L,mid-1);
        }else {
            son[x][0]=0;
        }
        build(x,1,son[x][1],mid+1,R);son[x][1]=cur[(mid+R+1)&gt;&gt;1];
        tot[x]=tot[son[x][1]]+tot[son[x][0]]+1;
        size[x]=size[son[x][1]]+size[son[x][0]]+1;
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>替罪羊树</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay学习笔记</title>
    <url>/2019/12/11/blog/Splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>伸展树（Splay）是一种平衡二叉树，即优化后的二叉查找树。伸展树可以自我调整，这就要依靠伸展操作Splay(x,S)，使得提升效率。</p>
</blockquote>
<p>&emsp;&emsp;假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。splay tree应运而生。splay tree是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</p>
<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><pre><code>size[]:自身和子树大小
num[]:该节点的数量(重复的值的个数)
val[]:权值
fa[]:父亲节点
son[][2]:左右子节点
root=0:总节点
cent=0:记录节点编号</code></pre><h1 id="各种操作"><a href="#各种操作" class="headerlink" title="各种操作"></a>各种操作</h1><h2 id="chk操作"><a href="#chk操作" class="headerlink" title="chk操作"></a>chk操作</h2><blockquote>
<p>辅助操作，查询节点是它父节点的左或右儿子。</p>
</blockquote>
<pre><code>return son[fa[x]][1]==x?1:0;</code></pre><h2 id="pushup操作"><a href="#pushup操作" class="headerlink" title="pushup操作"></a>pushup操作</h2><blockquote>
<p>辅助操作，更新size数组的值。</p>
</blockquote>
<pre><code>size[x]=num[x]+size[son[x][1]]+size[son[x][0]];</code></pre><h2 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate(旋转)"></a>rotate(旋转)</h2><blockquote>
<p>自然语言是多么的无力,请见代码</p>
</blockquote>
<pre><code>if(x==root)return;
int y=fa[x],z=fa[y],k=chk(x),w=son[x][k^1];//父亲和祖父节点，以及x相反的儿子
son[z][chk(y)]=x;fa[x]=z;
son[y][k]=w;fa[w]=y;
son[x][k^1]=y;fa[y]=x;
pushup(y);pushup(x);</code></pre><h2 id="splay伸展（核心）"><a href="#splay伸展（核心）" class="headerlink" title="splay伸展（核心）"></a>splay伸展（核心）</h2><blockquote>
<p><strong>将一个节点一路rotate到指定节点的儿子。</strong>如果该节点、该父节点和该爷爷节点「三点一线」，那么应该先旋转父节点。</p>
</blockquote>
<pre><code>public static void splay(int x,int goal) {
         if(x==0)return;
         while(fa[x]!=goal) {//不是指定节点
            int y=fa[x],z=fa[y];
             if(z!=goal) {
                 if(chk(x)==chk(y)) {//如果三点一线
                     rotate(y);
                 }else {
                     rotate(x);
                 }
             }
             rotate(x);
         }
         if(goal==0)root=x;//如果移动到根节点（fa[root]=0）
     }</code></pre><h2 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h2><blockquote>
<p>辅助操作，将<strong>最大的小于等于的数</strong>所在的节点splay到根。</p>
</blockquote>
<pre><code>if(root==0)return;
int cur=root;int d=val[cur]&lt;x?1:0;
while(son[cur][d]!=0&amp;&amp;val[cur]!=x) {
    cur=son[cur][d];d=val[cur]&lt;x?1:0;
}
splay(cur,0);</code></pre><h2 id="插入（insert）操作"><a href="#插入（insert）操作" class="headerlink" title="插入（insert）操作"></a>插入（insert）操作</h2><blockquote>
<p>从根节点开始，一路搜索下去。如果节点存在则直接自增cnt的值。否则新建节点并与父节点连边。</p>
</blockquote>
<p>因为新建节点时可能会拉出一条链，所以新建节点后需要将该节点splay到根节点。沿途的rotate操作可以使平衡树恢复平衡。</p>
<pre><code>public static void insert(int x) {//插入
        int cur=root,d=0;
        while(cur!=0&amp;&amp;val[cur]!=x) {//往下寻找这个数的位置
            d=cur;cur=son[cur][x&gt;val[cur]?1:0];
        }
        if(cur!=0) {//如果不是新数
            num[cur]++;
        }else {//如果是的话就新建一个节点。
            cur=++cent;
            if(d!=0)son[d][x&gt;val[d]?1:0]=cur;//父亲节点是真实节点
            fa[cur]=d;size[cur]=1;num[cur]=1;
            val[cur]=x;
        }
        splay(cur,0);
    }</code></pre><h2 id="查询-kth"><a href="#查询-kth" class="headerlink" title="查询(kth)"></a>查询(kth)</h2><blockquote>
<p>查询排名为k的数（从小到大）。从根节点开始，一路搜索下去。每次判断要走向哪个子树。注意考虑重复权值。</p>
</blockquote>
<pre><code>public static int kth(int k) {
  int cur=root;
  while(true) {
    if(son[cur][0]!=0&amp;&amp;k&lt;=size[son[cur][0]]) {//在左边
      cur=son[cur][0];
    }else if(son[cur][1]!=0&amp;&amp;k&gt;size[son[cur][0]]+num[cur] ){//在右边
      k-=size[son[cur][0]]+num[cur];
      cur=son[cur][1];
    }else { return cur;     }
  }
}</code></pre><h2 id="前驱-pre-与后继-succ"><a href="#前驱-pre-与后继-succ" class="headerlink" title="前驱(pre)与后继(succ)"></a>前驱(pre)与后继(succ)</h2><blockquote>
<p>定义: 在序列中，比某数小但最大的数和比某数大但却最小的数。将该节点（x）find到根后，根据性质就能找到。</p>
</blockquote>
<p><strong>注意</strong>，为防止没有前驱或者后继的情况下，事先在树中insert一个<strong>极大</strong>节点和一个<strong>极小</strong>节点。但在操作的时候要注意这两个节点的存在。</p>
<pre><code>public static int pre(int x) {//前驱
        find(x);
        if(val[root]&lt;x)return root;
        int cur=son[root][0];
        while(son[cur][1]!=0) cur=son[cur][1];
        return  cur;
    }
  public static int succ(int x) {//后续
          find(x);
          if(val[root]&gt;x) return root;
          int cur=son[root][1];
          while(son[cur][0]!=0) cur=son[cur][0];
          return cur;
      }</code></pre><h2 id="查询rank-rank"><a href="#查询rank-rank" class="headerlink" title="查询rank(rank)"></a>查询rank(rank)</h2><blockquote>
<p>查询某数的排名（从小到大）。并不需要专门写操作。将该节点find到根后返回左子树的权值数即可。(极小点也考虑进去了)</p>
</blockquote>
<pre><code>find(x);
sb.append((size[son[root][0]])+&quot;\n&quot;);</code></pre><h2 id="区间反转"><a href="#区间反转" class="headerlink" title="区间反转"></a>区间反转</h2><blockquote>
<p>向线段树打标记一样。打标记时，将和分别旋转到根节点和根节点右儿子处，那么的左子树即是区间。在其根处打上标记然后在查询大和输出中序遍历时下传标记即可。</p>
</blockquote>
<p><strong>注意</strong>，splay维持的性质左小右大是插入时认为的值。区间反转之后不影响。</p>
<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Scanner;

public class 模板 {
    static int size[]; //包括自身子树大小
    static int num[];//该节点的数量
    static int val[];//权值
    static int fa[];//父亲节点
    static int son[][];
    static int root=0,cent=0;//
    static StringBuilder sb;
    public static void main(String[] args) throws IOException {
        Input in = new Input();sb = new StringBuilder();
        int n=in.nextInt();
        size=new int[n+2];num=new int[n+2];
        val=new int[n+2];fa=new int[n+2];
        son=new int[n+2][2];
        insert(Integer.MIN_VALUE);
        insert(Integer.MAX_VALUE);
        for (int i = 0; i &lt;n; i++) {
            int d=in.nextInt(),x=in.nextInt();
            switch(d) {
            case 1: insert(x);break;
            case 2:remove(x);break;
            case 3:rank(x);break;//排名
            case 4:sb.append(val[kth(x+1)]+&quot;\n&quot;);break;//排名为x的数
            case 5:sb.append(val[pre(x)]+&quot;\n&quot;);break;//前驱
            case 6:sb.append(val[succ(x)]+&quot;\n&quot;);break;//后续
            }
        }
       System.out.println(sb);
    }
    public static void insert(int x) {//插入
        int cur=root,d=0;
        while(cur!=0&amp;&amp;val[cur]!=x) {//往下寻找这个数的位置
            d=cur;cur=son[cur][x&gt;val[cur]?1:0];
        }
        if(cur!=0) {//如果不是新数
            num[cur]++;
        }else {//如果是的话就新建一个节点。
            cur=++cent;
            if(d!=0)son[d][x&gt;val[d]?1:0]=cur;//父亲节点是真实节点
            fa[cur]=d;size[cur]=1;num[cur]=1;
            val[cur]=x;
        }
        splay(cur,0);
    }
    public static int kth(int k) {
        int cur=root;
        while(true) {
            if(son[cur][0]!=0&amp;&amp;k&lt;=size[son[cur][0]]) {
                cur=son[cur][0];
            }else if(son[cur][1]!=0&amp;&amp;k&gt;size[son[cur][0]]+num[cur] ){
                k-=size[son[cur][0]]+num[cur];
                cur=son[cur][1];
            }else { return cur;     }
        }
    }
    public static int pre(int x) {//前驱
        find(x);
        if(val[root]&lt;x)return root;
        int cur=son[root][0];
        while(son[cur][1]!=0) cur=son[cur][1];
        return  cur;
    }
    public static int succ(int x) {//后续
        find(x);
        if(val[root]&gt;x) return root;
        int cur=son[root][1];
        while(son[cur][0]!=0) cur=son[cur][0];
        return cur;
    }
    public static void remove(int x) {//删除
        int last=pre(x);int next=succ(x);
        splay(last,0);splay(next,last);
        int del=son[next][0];
        if(num[del]&gt;1) {
            num[del]--;
            splay(del,0);
        }else {
            son[next][0]=0;
        }
    }
    public static void rank(int x) {//查询
        find(x);
        sb.append((size[son[root][0]])+&quot;\n&quot;);
    }
    public static void find(int x) {
        if(root==0)return;
        int cur=root;int d=val[cur]&lt;x?1:0;
        while(son[cur][d]!=0&amp;&amp;val[cur]!=x) {
            cur=son[cur][d];d=val[cur]&lt;x?1:0;
        }
        splay(cur,0);
    }
     public static void splay(int x,int goal) {
         if(x==0)return;
         while(fa[x]!=goal) {
            int y=fa[x],z=fa[y];
             if(z!=goal) {
                 if(chk(x)==chk(y)) {
                     rotate(y);
                 }else {
                     rotate(x);
                 }
             }
             rotate(x);
         }
         if(goal==0)root=x;
     }
    public static void rotate(int x) {//旋转
        if(x==root)return;
        int y=fa[x],z=fa[y],k=chk(x),w=son[x][k^1];//父亲和祖父节点，以及x相反的儿子
        son[z][chk(y)]=x;fa[x]=z;
        son[y][k]=w;fa[w]=y;
        son[x][k^1]=y;fa[y]=x;
        pushup(y);pushup(x);
    }
    public static void pushup(int x) {
        size[x]=num[x]+size[son[x][1]]+size[son[x][0]];
    }
    public static int chk(int x) {
        return son[fa[x]][1]==x?1:0;
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>三维偏序</title>
    <url>/2019/12/09/blog/%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">传送门</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><del>模板题，没有思路</del></p>
<p>一个CDQ加上一个树状数组维护就ojbk了.对于相同元素的问题，可以把序列去重，这样现在就没有相同的了，给现在的每个元素一个权值vv等于出现的次数。</p>
<p><strong>注意</strong>开始结构体排序的时候，要排对呀！（关键字不能只有第一维）。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;
import java.util.Comparator;

public class P3810三维偏序 {
public static class off implements Comparable&lt;off&gt;{
  private int a,b,c;
  private int num,ans;
  public off() { }
  public off(int a,int b,int c) {
    this.a=a;this.b=b;this.c=c;
  }
  @Override
  public int compareTo(off o) {
    if(a&gt;o.a||(a==o.a&amp;&amp;(b&gt;o.b||(b==o.b&amp;&amp;c&gt;o.c)))) {
      return 1;
    }else if(a==o.a&amp;&amp;c==o.c&amp;&amp;b==o.b) {
      return 0;
    }
    return -1;
}
}
public static class cmpb implements Comparator&lt;off&gt;{
  @Override
  public int compare(off o1, off o2) {
    if(o1.b&gt;o2.b) {
      return 1;
    }else if(o1.b&lt;o2.b) {
      return -1;
    }
    return 0;
  }
}
public static class node{
  private int tre[],kk;
  public int lwbt(int x) {return x&amp;(-x);};
  public int ask(int u) {
    int ans=0;
    for (;u&gt;0;u-=lwbt(u)) {
      ans+=tre[u];
    }
    return ans;
  }
  public void add(int i,int k) {
    for (;i&lt;=kk;i+=lwbt(i)) {
      tre[i]+=k;
    }
  }
}
static int n,k;
static off d[],a[],s[];//操作元素，去重后的操作元素，拷贝元素数组
static int em=0;//辅助
static int cnt[];//记录答案
static node t;//工具
public static void main(String[] args) throws IOException {
  Input in = new Input();StringBuilder sb = new StringBuilder();
  n=in.nextInt();k=in.nextInt();
   t=new node();t.kk=k;t.tre=new int[k+1];
  d=new off[n+2];a=new off[n+1];
  for (int i =1; i &lt;d.length-1; i++) {
    d[i]=new off(in.nextInt(),in.nextInt(),in.nextInt());
  }
  d[n+1]=new off(123335991,12331,123312);
  Arrays.sort(d,1,d.length-1);
  int v=0;
  for (int i =1; i &lt;=n; i++) {
    v++;
    if(d[i].a!=d[i+1].a||d[i].b!=d[i+1].b||d[i].c!=d[i+1].c) {
      a[++em]=d[i];a[em].num=v;v=0;
    }
  }
  s=new off[em+1];
  CDQ(1,em);
  cnt=new int[n+1];
  for (int i =1;i&lt;=em; i++) {
    cnt[a[i].ans+a[i].num-1]+=a[i].num;
  }
  for (int i =0; i &lt;n; i++) {
    sb.append(cnt[i]+&quot;\n&quot;);
  }
  System.out.println(sb);
}
public static void CDQ(int L,int R) {
  if(L==R)return;
  int mid=(L+R)&gt;&gt;1;
  CDQ(L,mid);CDQ(mid+1,R);
  int q=mid+1,p=L;int v=0;
  while(p&lt;=mid&amp;&amp;q&lt;=R) {
    if(a[p].b&lt;=a[q].b) {
      s[++v]=a[p];
      t.add(a[p].c,a[p].num);p++;
    }else {
      s[++v]=a[q];
      s[v].ans+=t.ask(a[q].c);q++;
    }
  }
  while(p&lt;=mid) {//顺序
    t.add(a[p].c,a[p].num);
    s[++v]=a[p];p++;
  }
  while(q&lt;=R) {
    s[++v]=a[q];
    s[v].ans+=t.ask(a[q].c);q++;
  }
  for (int i =L;i&lt;=mid; i++) {
    t.add(a[i].c,-a[i].num);
  }
for (int i =L, j=1; i &lt;=R; i++,j++) {
  a[i]=s[j];
}
}
public static class Input {
  StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
  public int nextInt() throws IOException {
    in.nextToken();
    return (int)in.nval;
  }
  public long nextLong() throws IOException {
    in.nextToken();
    return (long)in.nval;
  }
}
}</code></pre>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪大陆</title>
    <url>/2019/12/09/blog/%E8%B4%AA%E5%A9%AA%E5%A4%A7%E9%99%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="https://www.luogu.com.cn/problem/P2184" target="_blank" rel="noopener">传送门</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;从字面上看就是每个查询区间的l与r，与多少<code>个</code>之前的覆盖区间（地雷）有交集。<br>把它换算一下理解就是，之前代表的是按时间顺序，假设查询区间左右端点是Lj和Rj，覆盖区间左右端点是Li和Ri,那么有交集的覆盖区间满足Li&lt;=Rj且Ri&gt;=L且i&lt;j。</p>
<p>&emsp;&emsp;很显然，这是一个三维偏序问题。元素储存操作类型（tye），左右端点（b，z）和第几个操作位数(a).<br>本题细节较多。<strong>注意</strong>清空（1）树状数组的操作位置的摆放（dbug我半天）。（2）数组数组的空间要确定，如果开小了，就莫名答案变负数了QAQ</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class P2184贪婪大陆 {
    public static class off{
        private int a,b,z,tye;
        public off() { }
        public off(int tye,int a,int b,int z) {
            this.a=a;this.b=b;this.tye=tye;
            this.z=z;
        }
    }
    public static class node{
        private int tre[],kk;
        public int lwbt(int x) {return x&amp;(-x);};
        public int ask(int u) {
            int ans=0;
            for (;u&gt;0;u-=lwbt(u)) {
                ans+=tre[u];
            }
            return ans;
        }
        public void add(int i,int k) {
            for (;i&lt;=kk;i+=lwbt(i)) {
                tre[i]+=k;
            }
        }
        public int query(int l,int r) {
            l--;
            int sum=0;
            while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
            while(l&gt;r) {sum-=tre[l];l-=lwbt(l);}
            return sum;
        }
    }
    static int n,m;//大小和操作数量
    static off d[],s[];//操作元素数组和拷贝数组
    static node t;//树状数组工具
    static boolean vis[];//判断是否是查询
    static int ans[];//储存答案
    public static void main(String[] args) throws IOException {
        Input in = new Input();StringBuilder sb = new StringBuilder();
        n=in.nextInt();m=in.nextInt();
        d=new off[n+1];t=new node();
        t.kk=n;t.tre=new int[n+1];s=new off[n+1];
        vis=new boolean[n+1];ans=new int[n+1];
        int x,y,z;
        for (int i =1; i &lt;=m; i++) {
            x=in.nextInt();y=in.nextInt();
            z=in.nextInt();if(x==2) {
                d[i]=new off(x,i,z,y);
                vis[i]=true;
            }else {
            d[i]=new off(x,i,y,z);
            }
        }
        CDQ(1,m);
        for (int i =1; i &lt;=m; i++) {
            if(vis[i]) {
                sb.append(ans[i]+&quot;\n&quot;);
            }
        }
        System.out.println(sb);
    }
    public static void CDQ(int L,int R) {
        if(L==R)return;
        int mid=(L+R)&gt;&gt;1;
        CDQ(L,mid);CDQ(mid+1,R);
        int p=L,q=mid+1,v=0;
        while(p&lt;=mid&amp;&amp;q&lt;=R) {
            if(d[p].b&lt;=d[q].b) {
                if(d[p].tye==1)t.add(d[p].z,1);
                s[++v]=d[p++];
            }else{
                if(d[q].tye==2) ans[d[q].a]+=t.query(d[q].z,n);
                   s[++v]=d[q++];
            }
        }
        while(q&lt;=R) {//注意顺序
            if(d[q].tye==2) ans[d[q].a]+=t.query(d[q].z,n);
            s[++v]=d[q++];
        }
        for (int i =L; i&lt;p; i++) {//上限到p就行了,清空在前,防止把后面的也算上了。
            if(d[i].tye==1)t.add(d[i].z,-1);
        }
        while(p&lt;=mid)s[++v]=d[p++];
        for (int i =L, j=1; i &lt;=R; i++,j++) {
            d[i]=s[j];
        }
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分</title>
    <url>/2019/12/09/blog/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>基于值域的整体二分。类似于一些决策单调性的分治，可以解决诸多区间第 kk 小或区间第 kk 大的问题。</p>
</blockquote>
<p>&nbsp;&nbsp;&emsp;&nbsp;把复杂的问题拆分成许多可以简单求的解子问题。但是这两种算法必须离线处理，不能解决一些强制在线的题目。不过如果题目允许离线的话，这两种算法能把在线解法吊起来打（如树套树）。</p>
<p>时间复杂度：O（(N+M)log^2 N） &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="https://www.luogu.com.cn/blog/Owencodeisking/post-xue-xi-bi-ji-cdq-fen-zhi-hu-zheng-ti-er-fen" target="_blank" rel="noopener">参考资料</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><pre><code>import java.util.Arrays;
import java.util.Scanner;

public class Main{

public static class off{//每个原子化操作元素
    private int op,x,y,z;
    public off(){ }
    public off(int op,int x,int y,int z){
        this.op=op;this.x=x;
        this.y=y;this.z=z;
    }
}
public static class node{//树状数组工具
    private int tre[],kk;
    public int lwbt(int x) {return x&amp;(-x);};
    public int ask(int u) {//求和
        int ans=0;
        for (;u&gt;0;u-=lwbt(u)) {
            ans+=tre[u];
        }
        return ans;
    }
    public void add(int i,int k) {//单点修改
        for (;i&lt;=kk;i+=lwbt(i)) {
            tre[i]+=k;
        }
    }
    public int query(int l,int r) {//区间求和
        l--;
        int sum=0;
        while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
        while(l&gt;r) {sum-=tre[l];l-=lwbt(l);}
        return sum;
    }
}
static off d[],sl[],sr[];
static node T;
static int n,m;
static int t=0;
static int ans[];
public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);
    n=sc.nextInt();m=sc.nextInt();
    d=new off[n+2*m+1];int a[]=new int[n+1];
    int op,x,y,z;T=new node();ans=new int[n+1];
    T.kk=n;T.tre=new int[n+1];
    for (int i =1;i&lt;=n; i++) {
    a[i]=sc.nextInt();
    d[++t]=new off(0,i,a[i],1);//赋值
    }
    for (int i =1; i&lt;=m; i++) {
        op=sc.nextInt();
        x=sc.nextInt();y=sc.nextInt();
        if(op==1){//查询
            d[++t]=new off(i,x,y,sc.nextInt());
        }else{//修改
            d[++t]=new off(0,i,a[x],-1);a[x]=y;
            d[++t]=new off(0,i,a[x],1);
        }
    }
    sl=new off[t+1];sr=new off[t+1];//备份数组
    solve(Integer.MIN_VALUE,Integer.MAX_VALUE,1,t);
    for (int i =1;i&lt;=m; i++) {
        if(ans[i]==0)continue;
        System.out.println(ans[i]);
    }
}
public static void solve(int L,int R,int st,int ed){//值域二分
    if(st&gt;ed)return;//操作序列为空
    if(L==R){//值域达到边界
        for (int i =st;i&lt;=ed; i++) {
            if(d[i].op&gt;0)ans[d[i].op]=L;
        }
        return;
    }
    int mid=(L+R)&gt;&gt;1;
    int l=0,r=0;
    for (int i =st;i&lt;=ed; i++) {
        if(d[i].op==0){//赋值操作
            if(d[i].y&lt;=mid){
                T.add(d[i].x,d[i].z);sl[++l]=d[i];
            }else{
             sr[++r]=d[i];
            }
        }else{//查询操作
            int cnt=T.query(d[i].x,d[i].y);
            if(cnt&gt;=d[i].z){
                sl[++l]=d[i];
            }else{
                d[i].z-=cnt;sr[++r]=d[i];
            }
        }
    }
    for (int i=ed; i&gt;=st;i--) {//清空树状数组
        if(d[i].op==0&amp;&amp;d[i].y&lt;=mid)T.add(d[i].x,-1*d[i].z);
    }
    for (int i =1; i&lt;=l; i++) {//拷贝
        d[st+i-1]=sl[i];
    }
    for (int i =1;i&lt;=r; i++) {
        d[st+i-1+l]=sr[i];
    }
    solve(L,mid,st,st+l-1);
    solve(mid+1,R,st+l,ed);
}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>cdq与整体二分</title>
    <url>/2019/12/07/blog/%E6%B5%85%E8%B0%88cdq%E4%B8%8E%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h1><blockquote>
<p>用于解决离线或不强制在线问题中简化一层树结构的实用性分治算法</p>
</blockquote>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>主要思想还是分治的思想，即递归处理小范围信息，之后将处理的信息合并上传。一般来说，都是先处理左区间，之后用左区间更新右区间，顺便更新答案，然后处理右区间，之后再将两个区间的信息合并。<br>这一类分治有一个重要的思想——用一个子问题来计算对另一个子问题的贡献。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>(1)在分治之前先按照某一关键字排序，之后在分治过程中，将信息按照时间分成前后两部分，这样避免了多次排序。</p>
<p>(2)在分治过程中，利用归并排序的方式将两个有序序列合并，将O(nlog)的排序变为O(n)的归并。</p>
<p>(3)在分治过程中，利用树状数组解决问题，除非必须用到别的东西。</p>
<p>(4)在分治过程中，利用有序的性质可以发现，逆序也是有序的，并且满足一些正好与正序相反，这样可以避免重复排序。</p>
<p>(5)在分治之前尽可能的简化不必要的信息，这样能减少整个代码的常数。</p>
<p>(6)另外，在更新右区间或者合并的时候，尽量选择常数与时间复杂度较小的算法，比如说能用单调队列就不要用斜率优化，能用斜率优化就不要用决策单调性。</p>
<h3 id="CDQ套CDQ"><a href="#CDQ套CDQ" class="headerlink" title="CDQ套CDQ"></a>CDQ套CDQ</h3><p><strong><a href="https://blog.csdn.net/weixin_33890499/article/details/94674020" target="_blank" rel="noopener">以下为借鉴内容</a></strong></p>
<h4 id="四维偏序问题"><a href="#四维偏序问题" class="headerlink" title="四维偏序问题"></a>四维偏序问题</h4><p><strong>给定N(N&lt;=20000)个有序四元组(a,b,c,d)，求对于每一个四元组(a,b,c,d)，有多少个四元组(a2,b2,c2,d2)满足a2&lt;a &amp;&amp; b2&lt;b &amp;&amp; c2&lt;c &amp;&amp; d2&lt;d。</strong></p>
<p>这个问题很容易用树套树解决，但是树套树巨大的常数和空间消耗往往是性能的瓶颈。记得我们之前说过，CDQ分<br>治能代替复杂的数据结构，并将问题“降维”。这里，我们就用双重嵌套的CDQ分治，把这个问题继续降维，避免使用树套树。</p>
<p>回忆二维偏序问题，我们对第一维分治之后，所有的二元组被我们划分为了左右两部分，左边和右边各自的内部问题已经通过递归解决，剩下要考虑的就是左边的修改对右边的查询的影响。我们不妨把分治后的二元组重新标记一下，左边的为(L,b)，右边的为(R,b)。这时候，(a1,b1)对(a2,b2)有影响，当且仅当a1 == L &amp;&amp; a2 == R &amp;&amp; b1 &lt; b2。然后我们按照b的顺序合并，解决了这一问题。</p>
<p>对于三维偏序问题也是一样的，对第一维分治并且重新标记之后，只有(L,b1,c1)可能对(R,b2,c2)有影响。我们用“按顺序归并”保证b元素的顺序，用树状数组保证c元素的顺序。</p>
<p>对于四维偏序问题，我们也按照这样的思路进行下去。对第一维分治，并把所有元素重新标记为(L,b,c,d)和(R,b,c,d)，然后按照b的顺序合并。注意，我们在这里只是做<strong>合并</strong>，并不用任何数据结构对c和d加以维护。</p>
<p>合并完之后，我们得到了一个按照b值升序排列的序列，现在，我们把这个序列复制一份，用CDQ分治统计刚刚我们没有统计的信息——<strong>左边的修改对右边的查询的影响。</strong></p>
<p>这时候这个序列仅仅是b值有序，但是a值是杂乱无章的，不过我们之前已经对a值进行了<strong>重新标记</strong>，现在a值只可能是L或者R。<br>我们对b值进行分治，递归处理左右两边的子问题（别忘了我们现在要处理的问题是“在第一维分治之后，左边的修改对右边的查询的影响”）。然后，把所有b值也重新标号为L和R，于是我们得到了这样一个序列(L/R,L/R,c,d)。注意，现在只有(L,L,c,d)可能对(R,R,c,d)产生影响！请读者仔细考虑这个条件，这是理解多重CDQ分治的关键！</p>
<p>然后我们按照c值从小到大进行合并，这保证了统计时c值的顺序，同时用树状数组维护d值的信息，保证考虑到d值的顺序。只有一个元素为(L,L,c,d)的时候，它才可能影响到后面的查询；只有一个元素为(R,R,c,d)的时候，它才可能收到前面的修改的影响。即，我们在归并的时候，把一个d值加入树状数组，当且仅当这个四元组的a == L &amp;&amp; b == L；我们向树状数组查询d值的信息并应用到这个查询上面，当且仅当这个四元组的a == R &amp;&amp; b == R。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>对第一维进行排序。</li>
<li>对第一维重新标号，然后对第一维分治，递归解决子问题，按照第二维的顺序合并。此时只是单纯的合并，并不进行统计。</li>
<li><strong>把合并后的序列复制一份</strong>，并对第二维重新标号，在复制的那一份中进行CDQ分治。即对第二维分治，递归解决子问题，按照第三维的顺序合并。合并过程中用树状数组维护第四维的信息。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>清空树状数组的时候，最好不要用函数清空,比如<strong>Arrays.fill(t.tre,0);</strong></li>
<li>赋值函数：<strong>System.arraycopy(s,1,a,L,v);</strong></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实用的板子</title>
    <url>/2019/12/07/blog/%E5%BF%AB%E8%AF%BB%E5%BF%AB%E8%BE%93%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="快读快输板子"><a href="#快读快输板子" class="headerlink" title="快读快输板子"></a>快读快输板子</h1><pre><code>public class 快读快输 {
    public static void main(String[] args) throws IOException {
        Input in = new Input();//输入
        StringBuilder sb = new StringBuilder();//输出
        int n=in.nextInt();
        sb.append(n+&quot;\n&quot;);
        System.out.println(sb);
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre><h1 id="树状数组简单工具板子"><a href="#树状数组简单工具板子" class="headerlink" title="树状数组简单工具板子"></a>树状数组简单工具板子</h1><pre><code>public static class node{
        private int tre[],kk;
        public int lwbt(int x) {return x&amp;(-x);};
        public int ask(int u) {
            int ans=0;
            for (;u&gt;0;u-=lwbt(u)) {
                ans+=tre[u];
            }
            return ans;
        }
        public void add(int i,int k) {
            for (;i&lt;=kk;i+=lwbt(i)) {
                tre[i]+=k;
            }
        }
    public int query(int l,int r) {
            l--;
            int sum=0;
            while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
            while(l&gt;r) {sum+=tre[l];l-=lwbt(l);}
            return sum;
        }
    }</code></pre><h1 id="LCA简单板子"><a href="#LCA简单板子" class="headerlink" title="LCA简单板子"></a>LCA简单板子</h1><pre><code>static int mo[][],deep[]; //LCA
mo=new int[n+2][21];fa=new int[n+2];deep=new int[n+2];
//LCA AND 预处理
    public static int LCA(int x,int y) {//公共祖先
        if(deep[x]&lt;deep[y]) {int c=x;x=y;y=c;}
        for (int i =19;i&gt;=0;i--) if(deep[mo[x][i]]&gt;=deep[y])x=mo[x][i];
        for (int i =19;i&gt;=0;i--) if(mo[x][i]!=mo[y][i]) {x=mo[x][i];y=mo[y][i];}
        return x==y?x:mo[x][0];
    }
    public static void dfs(int u,int fat) {//搜索
        mo[u][0]=fat;
        deep[u]=deep[fat]+1;
        for (int i =1; i&lt;=19; i++) {
            mo[u][i]=mo[mo[u][i-1]][i-1];
        }
        for (int i =head[u]; i!=-1;i=a[i].next) {
            int v=a[i].to;if(v==fat)continue;
            dfs(v,u);
        }
    }</code></pre>]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>板子</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP学习笔记</title>
    <url>/2019/11/27/blog/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h1><h3 id="游览器：web-browser-资源：resourse-客户端：client"><a href="#游览器：web-browser-资源：resourse-客户端：client" class="headerlink" title="游览器：web browser  资源：resourse  客户端：client"></a>游览器：web browser  资源：resourse  客户端：client</h3><h3 id="HTTP：HyperText-Transfer-Protocol-超文本传输协议。"><a href="#HTTP：HyperText-Transfer-Protocol-超文本传输协议。" class="headerlink" title="HTTP：HyperText Transfer Protocol , 超文本传输协议。"></a>HTTP：HyperText Transfer Protocol , 超文本传输协议。</h3><h3 id="协议-指规则的约定。（Protocol）"><a href="#协议-指规则的约定。（Protocol）" class="headerlink" title="协议: 指规则的约定。（Protocol）"></a>协议: 指规则的约定。（Protocol）</h3><h3 id="FTP-File-Transfer-Protocol-文本传输协议。"><a href="#FTP-File-Transfer-Protocol-文本传输协议。" class="headerlink" title="FTP : File Transfer Protocol, 文本传输协议。"></a>FTP : File Transfer Protocol, 文本传输协议。</h3><h3 id="DNS：Domain-Name-System-域名系统。"><a href="#DNS：Domain-Name-System-域名系统。" class="headerlink" title="DNS：Domain Name System.域名系统。"></a>DNS：Domain Name System.域名系统。</h3><h3 id="TCP-Transmission-Control-Protocol-传输协议控制。"><a href="#TCP-Transmission-Control-Protocol-传输协议控制。" class="headerlink" title="TCP: Transmission Control Protocol.传输协议控制。"></a>TCP: Transmission Control Protocol.传输协议控制。</h3><h3 id="UDP：User-Data-Protocol-用户数据报协议。"><a href="#UDP：User-Data-Protocol-用户数据报协议。" class="headerlink" title="UDP：User Data Protocol.用户数据报协议。"></a>UDP：User Data Protocol.用户数据报协议。</h3><h3 id="NIC：Network-Interface-Card-网络适配器。即网卡。"><a href="#NIC：Network-Interface-Card-网络适配器。即网卡。" class="headerlink" title="NIC：Network Interface Card.网络适配器。即网卡。"></a>NIC：Network Interface Card.网络适配器。即网卡。</h3><h3 id="MAC地址：网卡所属的固定的位置。-区域网：LAN"><a href="#MAC地址：网卡所属的固定的位置。-区域网：LAN" class="headerlink" title="MAC地址：网卡所属的固定的位置。  区域网：LAN"></a>MAC地址：网卡所属的固定的位置。  区域网：LAN</h3><h3 id="ARP：用于解析ip查出对应的MAC地址的协议"><a href="#ARP：用于解析ip查出对应的MAC地址的协议" class="headerlink" title="ARP：用于解析ip查出对应的MAC地址的协议"></a>ARP：用于解析ip查出对应的MAC地址的协议</h3><h3 id="URL-统一资源标识符。URI是URL的子集。"><a href="#URL-统一资源标识符。URI是URL的子集。" class="headerlink" title="URL: 统一资源标识符。URI是URL的子集。"></a>URL: 统一资源标识符。URI是URL的子集。</h3><h3 id="URI：统一资源定位符。"><a href="#URI：统一资源定位符。" class="headerlink" title="URI：统一资源定位符。"></a>URI：统一资源定位符。</h3>]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让大脑专注</title>
    <url>/2019/11/21/life/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%A7%E8%84%91%E4%B8%93%E6%B3%A8/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>我们的大脑喜欢碎片式的信息，而科技的进步，手机应用的不断增加，短内容的丰富，正好满足了我们大脑的需求，不断的挤压我们的时间，持续分散我们的注意力。我们大脑每天面临着过度的刺激，当我们想要分散注意力时，大脑也会通过多巴胺第一时间奖励我们，使我们在不同的受注意对象之间来回切换，我们该怎样使大脑更加平静？</p>
</blockquote>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.bilibili.com/video/av75883891" target="_blank" rel="noopener">如何让你的大脑专注？</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>给自己的大脑更多空间，就是说给自己放空的机会，这样可以有更多更新颖的想法。比如洗澡、泡澡、做按摩就是放松大脑的好机会。</li>
<li>我们都以为注意力分散是集中注意的敌人、原因，其实它只是大脑超载的一种表现。</li>
<li>尝试着限制屏幕使用时间，持续一周多就会有明显的改变，如注意广度的增加等等好处。</li>
<li>我认为精神集中的<strong>前提</strong>是大脑保持清醒或者说是放松状态，人们所常说的发呆，打发时间其实就是一种让大脑放松的形式。很多伟大的想法都是在不经意间像出来的，大脑的发散性能帮助我get good idea。</li>
<li>放松的时候，大脑的思维模式是没有局限性的，可以增加思维的广度，缓解压力。可以选择一种放松，每天给自己的大脑放松放松（<del>打游戏</del>）。</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>人像摄影</title>
    <url>/2019/11/19/blog/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/</url>
    <content><![CDATA[<h1 id="布光"><a href="#布光" class="headerlink" title="布光"></a>布光</h1><h2 id="伦勃朗光"><a href="#伦勃朗光" class="headerlink" title="伦勃朗光"></a>伦勃朗光</h2><blockquote>
<p>给人脸形成很好的高光和影调</p>
</blockquote>
<p>位置：人物前左右四十五度斜上方，打在人物脸部<br>描述：对人物脸部有点要求 ，会在人物脸部背光的一侧形成三角形的高光区。</p>
<h2 id="环形光"><a href="#环形光" class="headerlink" title="环形光"></a>环形光</h2><blockquote>
</blockquote>
<p>位置：20到30度，灯光稍微高于人物眼睛，从上往下打。</p>
<h2 id="正面偏顶光"><a href="#正面偏顶光" class="headerlink" title="正面偏顶光"></a>正面偏顶光</h2><blockquote>
<p>会在下巴，鼻子下面形成很强烈的阴影，由此让模特侧着，抬起下巴。</p>
</blockquote>
<p>位置：顾名思义</p>
<h2 id="90度光"><a href="#90度光" class="headerlink" title="90度光"></a>90度光</h2><blockquote>
<p>富有戏剧效果，不建议女性拍摄角度，男性显得神秘感些。</p>
</blockquote>
<p>位置：90度</p>
<h2 id="蝴蝶光"><a href="#蝴蝶光" class="headerlink" title="蝴蝶光"></a>蝴蝶光</h2><blockquote>
<p>人物鼻子下面会有一个类似蝴蝶一样的阴影</p>
</blockquote>
<p>位置：从人物正上方，45度打下来。<br>描述：通常人物下面会有一个反光板，填充人物面部的阴影，增加一个很好看的眼神光（天气很好没强光的时候一样）</p>
<h2 id="背光"><a href="#背光" class="headerlink" title="背光"></a>背光</h2><blockquote>
<p>有剪影效果，摆姿纯侧面，拍轮廓。</p>
</blockquote>
<p>位置：后面<br>描述：用手摸额头或者脖子加以修饰。</p>
<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><p> 建议模特向灯光偏一点，起显瘦效果。</p>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol>
<li><strong>熟悉模特的风格</strong>。和模特沟通好，拍些手部等特写。</li>
<li><strong>合适焦段</strong>。可以利用场景中的线条引导，形成很好的构图。</li>
<li><strong>融入场景</strong>。不用一直对着镜头，拍自然的照，使用高速连拍，一顿快拍，定格自然的照片（如转圈圈）。</li>
<li>使用<strong>小道具</strong>。增加前景虚化的效果让画面唯美一些，比如说三棱镜，一片简简单单的叶子。</li>
<li><strong>正方体构图法</strong>。把模特想象在一个正方体里面，在八个角去拍摄。</li>
<li><strong>前景虚化</strong>。比如说把相机放在草地上拍摄小姐姐，用树枝当前景等。</li>
<li><strong>裁切</strong>。拍摄边界的地方注意。</li>
<li><strong>模特pose</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>景物拍攝</title>
    <url>/2019/11/19/blog/%E6%99%AF%E7%89%A9%E6%8B%8D%E6%94%9D/</url>
    <content><![CDATA[<h1 id="天空"><a href="#天空" class="headerlink" title="天空"></a>天空</h1><blockquote>
<p>将天空为背景，加入一些生活中常见的景物，让画面简洁又美观，反向衬托。</p>
</blockquote>
<p>  比如篮球架，屋顶，云朵等</p>
<h1 id="亦真亦假虚实结合"><a href="#亦真亦假虚实结合" class="headerlink" title="亦真亦假虚实结合"></a>亦真亦假虚实结合</h1><blockquote>
<p>利用小道具，如手办等，场景拍摄，显得真实感</p>
</blockquote>
<h1 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h1><blockquote>
<p>注重色彩的表现张力</p>
</blockquote>
<p>可以选择在有水洼的地方拍摄，通过水洼的反射光，形成色彩丰富的前景。如电影拍摄街道的时候，地不会是干的。<br>拍摄街道车辆灯尾驶出的效果。可以三脚架支持，快门调制2s左右。<br>充分运用花里胡哨的灯光特效，抓拍，定格，一闪而过，精彩的场景。</p>
]]></content>
      <categories>
        <category>攝影</category>
      </categories>
      <tags>
        <tag>攝影</tag>
      </tags>
  </entry>
  <entry>
    <title>图片管理2</title>
    <url>/2019/11/18/blog/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%862/</url>
    <content><![CDATA[<h1 id="awd"><a href="#awd" class="headerlink" title="awd"></a>awd</h1><p><img src="/.com//123.jpg" alt="asd"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的日常操作</title>
    <url>/2019/11/09/engineer/HexoCode/</url>
    <content><![CDATA[<h1 id="博文的写作"><a href="#博文的写作" class="headerlink" title="博文的写作"></a>博文的写作</h1><blockquote>
<p>hexo new [Layout] <code>&lt;</code>title<code>&gt;</code></p>
</blockquote>
<p> <a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">参考文档</a> <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">参考文档2</a><br>  默认的布局(Layout)是post，可以通过改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局。</p>
<h2 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h2><ul>
<li>默认文章布局有<code>post</code>,<code>page</code>和<code>draft</code>。</li>
<li>在创建不同类型的文件的时候会被保存在不同的路径上；</li>
<li>而自定义的布局会和post相同，被保持在<code>source/_posts</code>文件夹中。</li>
</ul>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p>
<pre><code>$ hexo publish [layout] &lt;title&gt;</code></pre><p>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/.com//123.jpg" alt="没有描述"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h1 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h1><pre><code>hexo -c 清除缓存
hexo -g 生成静态文件
hexo -d 布置网站
hexo -s 调试</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>当想强制定义自己创建文件的路径时可以在命令行中加上<code>--path</code>字段<br>比如：<code>$ hexo new --path engineer/Code &quot;Hexo&quot;</code></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom编写MarkDown</title>
    <url>/2019/11/09/engineer/AtomMD/</url>
    <content><![CDATA[<h1 id="Atom简介"><a href="#Atom简介" class="headerlink" title="Atom简介"></a>Atom简介</h1><ul>
<li>Atom是GitHub开发的一款跨平台（Windows、Mac、Linux）文本编辑器，2015年Atom正式发布1.0版，开源，至于收费目前还没有听说，传言成熟后商用会收费；</li>
<li>Atom是基于web技术构建的，界面看起来比其他的IDE更美观、更现代化。</li>
</ul>
<h1 id="Atom常用快捷键"><a href="#Atom常用快捷键" class="headerlink" title="Atom常用快捷键"></a>Atom常用快捷键</h1><pre><code>Crtl+Shift+M    打开默认Markdown实时预览
Crtl+Shift+p    打开搜索面板，可以查询安装包、Themes等各种选项
Crtl+Shift+f    全局查找和替换(默认不区分大小写，Crtl+Shift+c可以切换是否区分)
Crtl+f          文件内查找和替换(默认不区分大小写，Crtl+Shift+c可以切换是否区分)
Crtl+\          显示或隐藏目录树
Crtl+Alt+b      格式化代码（需要安装atom-beautify）</code></pre>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>xml注意事项</title>
    <url>/2019/11/09/engineer/xml/</url>
    <content><![CDATA[<p>##XML格式</p>
<blockquote>
<p>最首先（绝对是第一行）的是文档申明<br>申明格式<?xml version="1.0" encoding="UTF-8" ?></p>
</blockquote>
<ol>
<li>文档声明之后的第一个标签（根标签）之后,所有的标签都要在这个之中，一个xml文件只有<strong>一个根标签</strong>，起到规范性，单元性。</li>
</ol>
<p>##CDATA<br>定义：非法字符集<br>其替代品不会被xml的解析器所解析<br>###内容<br>      &lt;         &lt;<br>      &gt;         &gt;<br>      &apos;       ‘<br>      &amp;        &amp;<br>      &amp;quot        “</p>
<p><strong>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束：</strong></p>
<p>##解析方式<br>###DOM：<br>把整个xml全部读到内存当中，形成树状结构。把整个文档称之为document对象。<br>缺点：如果文件很大，会内存溢出。<br>优点：如果文档比较小就解析快。可以进行文档的增删操作。<br>###SAX<br>基于事件驱动。读一行，解析一行。<br>优点：不会造成内存溢出。<br>缺点：不可以进行文档的增删操作。只能进行查询。</p>
<p>##如何实现<br>手段：dom4j<br>位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml 里面的jar<br>使用跟jdbc一样build path。<br>###流程</p>
<ol>
<li>创建sax读取对象<br>SAXReader reader=new SAXReader();</li>
<li>指定解析的xml源<br>Document d=reader.read(new File(“src/Xml/Damo01.xml”));<br>格式；reader.read(new File(工程下的路径地址的字符串));</li>
<li>得到根元素<br>Element root= d.<strong>getRootElement()</strong>;</li>
<li>获取元素<blockquote>
<p>element.element(“stu”) : 返回该元素下的第一个stu元素<br>element.elements(); 返回该元素下的所有子元素。</p>
</blockquote>
</li>
</ol>
<p>List<Element> elements = root.elements();<br>遍历所有的stu元素<br>for (Element element : elements) {<br>获取stu元素下面的name元素<br>String name = element.element   (“name”).getText();<br>String age = element.element  (“age”).getText();<br>String address = element.element   (“address”).getText();<br>System.out.println(“name=”+name+”==age+”+age+”==address=”+address);<br>}</Element></p>
<p>###Dom4j 的 Xpath使用</p>
<blockquote>
<p> dom4j里面支持Xpath的写法。 xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。<br> 说明文档位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml</p>
</blockquote>
<ol>
<li><p>添加jar包依赖<br>jaxen-1.1-beta-6.jar<br>位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml\dom4j-1.6.1\lib</p>
</li>
<li><p>在查找指定节点的时候，根据XPath语法规则来查找</p>
</li>
<li><p>后续的代码与以前的解析代码一样。</p>
</li>
</ol>
<pre><code>//要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。
Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;);
System.out.println(nameElement.getText());


System.out.println(&quot;----------------&quot;);

//获取文档里面的所有name元素
List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;);
for (Element element : list) {
    System.out.println(element.getText());
}</code></pre><p>注意：“//AA”双斜杠AA是所有AA标签下的，“/”代表路径</p>
<p>##xml文档约束（看笔记）</p>
<blockquote>
<p>DTD<br>Schema</p>
</blockquote>
<p>##服务器<br>###tomcat</p>
<ul>
<li>是个静态的，当你更新完的时候记得重启服务器</li>
</ul>
<p>###1.  拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问：</p>
<pre><code>http://localhost:8080/stu.xml</code></pre><ul>
<li><p>在webaps下面新建一个文件夹xml  , 然后拷贝文件放置到这个文件夹中</p>
<pre><code>http://localhost:8080/xml/stu.xml
http://localhost:8080 ： 其实对应的是到webapps/root
http://localhost:8080/xml/ : 对应是 webapps/xml

使用IP地址访问：

http://192.168.37.48:8080/xml/stu.xml</code></pre></li>
</ul>
<p>###2. 配置虚拟路径<br>好处：自定义路径名称</p>
<p>##小细节</p>
<ol>
<li>当你文件写的时候是gbk，然而保存的时候编码选择是ANSI（本地默认的本地编码，一般就是GBK）时就会乱码应为游览器的编码是UTF-8，这个时候要改变编码模式，比如UTF-8.</li>
<li>GBK与UTF-8。比如GBK是一次性读一个字节，而中文一般是两个字节的。所以乱码问题就是编码模式没有保持一致性。</li>
<li>但工程<strong>带有感叹号</strong>的时候，多半就是你的 Build path 中多了双重的jar文件，导致某些jar被kill了。<br>解决方式：右键工程 build path 中的configure build path，在libar的框里面把一个jar删去（remove）。</li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>图片管理</title>
    <url>/2019/10/23/blog/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><img src="/.com//123.jpg" alt="meizi"><br>真香！！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2019/10/23/blog/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><ul>
<li>使用#号进行标记标题级别<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题</code></pre></li>
</ul>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><blockquote>
<p>每行末尾空两格再回车</p>
</blockquote>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><blockquote>
<p>在一行中用三个以上的星号、减号、底线来建立一个分隔线。</p>
</blockquote>
<hr>
<p>————如这样————</p>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><blockquote>
<p>再文字的两端加上两个波浪线</p>
</blockquote>
<p><del>阿瓦达</del><br>​<code>~~啊瓦达~~</code></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><blockquote>
<p>可以通过HTML的​<code>&lt;u&gt;​</code>标签来实现</p>
</blockquote>
<pre><code>&lt;u&gt;带下划线的内容&lt;/u&gt;</code></pre><h2 id="首行缩进空格"><a href="#首行缩进空格" class="headerlink" title="首行缩进空格"></a>首行缩进空格</h2><p>（1） 一个空格大小的表示：<code>&amp;ensp;</code>或者<code>&amp;#8194;</code><br>（2） 两个空格大小的表示：<code>&amp;emsp;</code>或者<code>&amp;#8195;</code></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><blockquote>
<p>MarkDown 支持有序列表 和 无序列表</p>
</blockquote>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><blockquote>
<p>无序列表使用星号(*****)、加号(+)或是减号(-)作为列表标记</p>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><blockquote>
<p>有序列表使用数字并加上 . 号空格来表示</p>
</blockquote>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><blockquote>
<p>列表嵌套只需在子列表中的选项添加四个空格即可</p>
</blockquote>
<pre><code>1.parent1
    +p1-child1
    +p1-child2
2.parent2
    -p2-child1
    -p2-child2</code></pre><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><blockquote>
<p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br>区块是可以嵌套的</p>
</blockquote>
<pre><code>&gt; MarkDown

&gt;&gt; MarkDown</code></pre><p>区块于列表结合</p>
<blockquote>
<p>1.区块中使用列表<br>2.列表中使用区块</p>
</blockquote>
<pre><code>&gt; 区块中使用列表
&gt; 1. 有序
&gt; + 无序
&gt; 2. 有序
&gt; - 无序

1. 列表中使用区块
    &gt; 区块内容
    &gt;&gt; 区块内容
2. 列表中使用区块</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code>[链接名称](链接地址)
或者
&lt;链接地址&gt;

// 例：
[百度](www.baidu.com)
&lt;www.baidu.com&gt;</code></pre><h2 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h2><blockquote>
<p>链接也可以用变量来代替，文档末尾附带变量地址</p>
</blockquote>
<pre><code>百度[百度][1]
教育宝[教育宝][jyb]

[1]:www.baidu.con
[jyb]:https://www.jiaoyubao.cn/</code></pre><p><a href="www.baidu.con">百度</a></p>
<h1 id="引用本地图片"><a href="#引用本地图片" class="headerlink" title="引用本地图片"></a>引用本地图片</h1><blockquote>
<p>在hexo中把图片放在与博客同名的文件夹中，然后只用 <code>![图片描述](图片文件名)</code>就可以引用了。</p>
</blockquote>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="一小代码"><a href="#一小代码" class="headerlink" title="一小代码"></a>一小代码</h2><blockquote>
<p>可以用字符 ` 括起来。</p>
</blockquote>
<p>比如说<code>代码</code>。</p>
<pre><code>比如说`代码`。</code></pre><h2 id="一大代码"><a href="#一大代码" class="headerlink" title="一大代码"></a>一大代码</h2><blockquote>
<p>整体缩进两次就行</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2019/10/23/blog/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p><a href="https://www.luogu.org/problem/P1495" target="_blank" rel="noopener">相关题面</a></p>
<h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><pre><code>int intchina(int r)
{
int Mi,x,y,d,ans=0;M=1;
for(int i=1;i&lt;=r;i++) M*=m[i];
for(int i=1;i&lt;=r;i++){
    M[i]=M/m[i];
    exgcd(Mi,m[i],d,x,y);
    ans=(ans+Mi*x*a[i])%M;
}
return (ans+M)%M; //正解
}</code></pre><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">相关题面</a></p>
<h2 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h2><pre><code>ll exgcd(ll a,ll b,ll &amp;x1, ll &amp;y1)
{
    if(!b)
    {
        x1=1;
        y1=0;
        return a;
    }
    ans=exgcd(b,a%b,x1,y1);
    ll t=x1;  //交换逆向求解
    x1=y1;
    y1=t-a/b*y1;
    return ans;
}</code></pre><ol>
<li>xa/d-yb/d=A/d这个方程就是扩展欧几里得exgcd(a,b,x,y)（忽略y前的负号），这样可以解出x，此时的x不是最优解，还要转换，即((x*(A/d))%(b/d)+(b/d))%(b/d)【求最小解的式子，不理解先背下来】。d是模。</li>
<li>当x不是最小正数解时，写成 x = (x % b + b) % b;循环至为正；</li>
</ol>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<p>————未学待补————</p>
</blockquote>
<hr>
<h1 id="二次剩余CipollaCipolla"><a href="#二次剩余CipollaCipolla" class="headerlink" title="二次剩余CipollaCipolla"></a>二次剩余CipollaCipolla</h1><p><a href="https://www.cnblogs.com/bztMinamoto/p/10664973.html" target="_blank" rel="noopener">学习资料1</a><br><a href="https://www.luogu.org/blog/oieremtkotori/2-0v0" target="_blank" rel="noopener">学习资料2</a></p>
<blockquote>
<p>————未学待补————</p>
</blockquote>
<hr>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>欧拉函数是小于x的整数中与x互质的数的个数，一般用φ(x)表示。特殊的，φ(1)=1。</p>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>先介绍一下什么是积性函数，后面将会用到。若当m与n互质时，f(m∗n)=f(m)∗f(n)，那么f是积性函数。若对任意正整数，都有f(m<em>n)=f(m)</em>f(n)成立，则f是完全积性函数。</p>
<p>##性质</p>
<ol>
<li>对于质数p,它的欧拉函数等于p-1.</li>
<li>若p为质数，n=p的k次方，则欧拉函数等于p^k-p^(k-1).比如说n的k次方分解质数只有p，则(p^k)*(1-1/p);</li>
<li>欧拉函数是积性函数，但不是完全积性函数。若m,n互质。则φ(m∗n)=φ(m)∗φ(n).特殊的，当m=2，n为奇数时，φ(2*n)=φ(n)。</li>
<li>当n&gt;2时，φ(n)是偶数.</li>
<li>小于n的数中,与n互质的数的总和为：φ(n)*n/2(n&gt;1);</li>
<li>n的因数的欧拉函数（包括1和它自己）的欧拉函数之和等于n。</li>
<li></li>
</ol>
<pre><code>  public static long ask(long m){//查单个欧拉函数
          long ans=m;
          for (long i =2; i*i&lt;=m; i++) {
              if(m%i==0){
                  ans=ans/i*(i-1);
                  while(m%i==0)m/=i;
              }
          }
          if(m&gt;1)ans=ans/m*(m-1);
          return ans;
      }

  public static void euler(int n) {//求一堆
    phi[1]=1;//特判
    for (int i =2; i &lt;=n; i++) {
        if(!flag[i]) {//判断是不是质数
            prime[++cent]=i;
            phi[i]=i-1;
        }
        for (int j =1; j&lt;=cent&amp;&amp;prime[j]*i&lt;=n; j++) {//欧拉筛
            flag[i*prime[j]]=true;//标记非质数
            if(i%prime[j]==0) {
                phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子
                break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次
            }else {
                phi[i*prime[j]]=phi[i]*phi[prime[j]];//积性函数
            }
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>伟大尝试</title>
    <url>/2019/10/23/%E4%BC%9F%E5%A4%A7%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>开始新的篇章<br>欢迎来到我的世界</p>
</blockquote>
<h1 id="阿瓦达"><a href="#阿瓦达" class="headerlink" title="阿瓦达"></a>阿瓦达</h1><h2 id="瓦大的有读"><a href="#瓦大的有读" class="headerlink" title="瓦大的有读"></a><em>瓦大的有读</em></h2><hr>
<h2 id="沃兹"><a href="#沃兹" class="headerlink" title="沃兹"></a><u>沃兹</u></h2><ol>
<li>awdawd</li>
<li>12321</li>
</ol>
<hr>
<ul>
<li>awdaw<blockquote>
<p>adawd</p>
<blockquote>
<p>awdawdwad</p>
<blockquote>
<p>awdawd</p>
<blockquote>
<p>dawdwadaw</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>有序</li>
</ol>
<ul>
<li>无序</li>
</ul>
<ol start="2">
<li>有序</li>
</ol>
<ul>
<li>无序</li>
</ul>
</blockquote>
<ol>
<li>列表中使用区块<blockquote>
<p>区块内容</p>
<blockquote>
<p>区块内容</p>
</blockquote>
</blockquote>
</li>
<li>列表中使用区块</li>
</ol>
<p><a href="www.baidu.com">百度</a><br>| awdaw | 啊达瓦 |</p>
<p><del>ad</del></p>
]]></content>
      <categories>
        <category>废话</category>
      </categories>
      <tags>
        <tag>废话</tag>
      </tags>
  </entry>
</search>
