<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>组合数问题</title>
    <url>/2020/03/30/Problem/P2822_%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://www.luogu.com.cn/problem/P2822" target="_blank" rel="noopener">题目</a></h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote>
<p>此题可打表</p>
</blockquote>
<p>打表： 应用杨辉三角，求出组合数表。</p>
<p>即使打过表，算法的复杂度其实还多的一维。<br>前缀和，有效减少查询统计时的复杂度，每一次查询O(n)降到O(1)。<br><code>ans[i][j]=ans[i][j-1]+ans[i-1][j]-ans[i-1][j1]ans[i][j]=ans[i][j−1]+ans[i−1][j]−ans[i−1][j−1]</code></p>
<p><img src="/.com//1.PNG" alt="公式"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>inline void build()
{
  c[0][0]=1;
  c[1][0]=c[1][1]=1;
  for(int i=2;i&lt;=2000;i++)
  {
    c[i][0]=1;
    for(int j=1;j&lt;=i;j++)
    {
      c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
      ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];//前缀和。
      if(!c[i][j])ans[i][j]++;//如果满足结论，计数加一。(有没有感觉很像我的玄学优化）
    }
    ans[i][i+1]=ans[i][i];//继承。
  }
}
inline void solve()
{
  t=read(),k=read();
  build();
  while(t--)
  {
    n=read(),m=read();
    if(m&gt;n)printf(&quot;%lld\n&quot;,ans[n][n]);//如果m&gt;n,ans只会达到n，只需输出ans[n,n]就可以了。
    else printf(&quot;%lld\n&quot;,ans[n][m]);
  }
}</code></pre>]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>配对统计</title>
    <url>/2020/03/29/Problem/P5677_%E9%85%8D%E5%AF%B9%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://www.luogu.com.cn/problemnew/solution/P5677" target="_blank" rel="noopener">题目</a></h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote>
<p>一个经典的区间问题</p>
</blockquote>
<p>首先可以预处理出每一个数的配对数，最多两个。<br>问题是求区间配对数，所以我们可以套路<strong>离线处理</strong>。从右到左，区间左端点为第一关键字，用树状数组实时更新配对数，来回答查询区间。<br><strong>每次加入L&lt;=x的配对，查询所有满足y&lt;=的配对.（x&lt;y）</strong></p>
<pre><code>不定长数组实现
static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; d;</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.ArrayList;
import java.util.Arrays;

public class P5677_配对统计 {

    public static class node{
        private int tre[],kk;
        public node(int kk) {
            tre=new int[kk+1];this.kk=kk;
        }
        public int lwbt(int x) {return x&amp;(-x);};
        public int ask(int u) {
            int ans=0;
            for (;u&gt;0;u-=lwbt(u)) {
                ans+=tre[u];
            }
            return ans;
        }
        public void add(int i,int k) {
            for (;i&lt;=kk;i+=lwbt(i)) {
                tre[i]+=k;
            }
        }
    public int query(int l,int r) {
            l--;
            int sum=0;
            while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
            while(l&gt;r) {sum+=tre[l];l-=lwbt(l);}
            return sum;
        }
    }
    public static class off implements Comparable&lt;off&gt;{
        private int va,id;
        public off(int va,int id) {
            this.id=id;this.va=va;
        }
        @Override
        public int compareTo(off o) {
            if(va&gt;o.va) {
                return 1;
            }
            return -1;
        }
    }


    static node h;
    static int n,m;
    static off a[];
    static ArrayList&lt;Integer&gt; c;
    static ArrayList&lt;ArrayList&lt;Integer&gt;&gt;  q1,q2,d;
    static int ans[];
    public static void main(String[] args) throws IOException {
        n=nextInt();m=nextInt();a=new off[n+1];h=new node(n+1);ans=new int[m+1];
        d=new ArrayList();q1=new ArrayList&lt;&gt;();q2=new ArrayList&lt;&gt;();c=new ArrayList&lt;&gt;();
        int x,y,md;
        for (int i =1; i &lt;=n; i++) {
            a[i]=new off(nextInt(),i);d.add(new ArrayList&lt;&gt;());q1.add(new ArrayList&lt;&gt;());q2.add(new ArrayList&lt;&gt;());
        }
        Arrays.sort(a,1,a.length);
        for (int i =1; i &lt;=n; i++) {
            md=Integer.MAX_VALUE;
            if(i!=1)md=min(a[i].va-a[i-1].va,md);
            if(i!=n)md=min(a[i+1].va-a[i].va,md);
            if(i!=1&amp;&amp;md==a[i].va-a[i-1].va)insert(a[i].id,a[i-1].id);
            if(i!=n&amp;&amp;md==a[i+1].va-a[i].va)insert(a[i].id,a[i+1].id);
        }
        for (int i =1; i &lt;=m; i++) {
            x=nextInt();q1.get(x-1).add(nextInt());q2.get(x-1).add(i);
        }
        for (int i =n; i&gt;0;i--) {
            for (int j = 0; j &lt;d.get(i-1).size(); j++)h.add(d.get(i-1).get(j),1);
            for (int j = 0; j &lt;q1.get(i-1).size(); j++)ans[q2.get(i-1).get(j)]=h.ask(q1.get(i-1).get(j));
        }
        long sum=0;
        for (int i =1; i &lt;=m; i++) {
            System.out.println(ans[i]);
            sum+=(long)ans[i]*i;
        }
        System.out.println(sum);
    }
    public static void insert(int x,int y) {
        d.get(Math.min(x,y)-1).add(max(x,y));
    }
    public static int max(int x,int y) {
        return Math.max(x,y);
    }
    public static int min(int x,int y) {
        return Math.min(x,y);
    }
    public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in),32768));
    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    public static double nextDouble() throws IOException{ in.nextToken(); return in.nval; }
    public static float nextFloat() throws IOException{ in.nextToken(); return (float)in.nval; }
    public static int nextInt() throws IOException{ in.nextToken(); return (int)in.nval; }
    public static String next() throws IOException{ in.nextToken(); return in.sval;}

}</code></pre>]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>区间</tag>
      </tags>
  </entry>
  <entry>
    <title>Scarlet的字符串不可能这么可爱</title>
    <url>/2020/03/29/Problem/P4925_Scarlet%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E8%83%BD%E8%BF%99%E4%B9%88%E5%8F%AF%E7%88%B1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://www.luogu.com.cn/problem/P4925" target="_blank" rel="noopener">题目</a></h1><p>Scarlet妄图构造字符集为kk，长度为LL的字符串，满足没有任何一个长度超过11的回文连续子串。</p>
<p>看起来这样的字符串太多了，Scarlet随手加了个限制：她指定了字符串的第ss位为ww。</p>
<p>这下Scarlet不会做了，请你来帮她计算究竟有多少满足条件的字符串。按照套路，你只要求出答案对pp取模后的结果。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote>
<p>对于一个不回文的字符串，每一位的选取会影响它后两位的选取</p>
</blockquote>
<p>由上可知，当字符集为k时，第一位有<strong>k</strong>种可能，第二位受第一位影响只能选<strong>（k-1）</strong>种字符，而第三位又受第一位和第二位影响，只有<strong>k-2</strong>种选。<br>以此类推。假如长度为n，大于2的时候,可能数量为<strong>k(k-1)((k-2)^(n-2))</strong>。</p>
<p>至于限制条件，指定某个位置的字符。<br>假设限制第一位，答案：<strong>1X(k-1)X(k-2)…..</strong><br>假设限制第二位。答案：<strong>(k-1)X(1)X(k-2)….</strong><br>假设限制第三位。答案：<strong>(k-1)X(k-2)X(1)….</strong><br>假设限制第四位。答案：<strong>(k-2)X(k-2)X(k-1)X(1)….</strong><br>可以轻松看出，指定哪个位置都是一样的结果（除非没有限制s=0)。</p>
<p><del>公式一写，快速幂一优化就OK了</del></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import java.util.Scanner;
public class P4925 {
    static long c;
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        long k=sc.nextLong(),l=sc.nextLong();c=sc.nextLong();
        long s=sc.nextLong(),w=sc.nextLong();k%=c;
        if(l==1) {
            if(s&gt;0) {
                System.out.println(1);
            }else {
                System.out.println(k);
            }
        }else {
            long ans=1;
            if(s&gt;0) {
                ans=ans*(k-1)%c;
            }else {//如果没有限制
                ans=ans*k*(k-1)%c;
            }
            k-=2;
            ans=(ans*divide(k,l-2))%c;
            System.out.println(ans);
        }

    }
    private static long divide(long a, long b) {//套模板
        if (b == 0)
            return 1;
        else if (b % 2 == 0) {
            return divide((a % c) * (a % c), b / 2) % c;
        } else
            return a % c * divide((a % c) * (a % c), (b - 1) / 2) % c;
    }
}</code></pre>]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷_P2671求和</title>
    <url>/2020/03/25/Problem/%E6%B4%9B%E8%B0%B7P2671_%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://www.luogu.com.cn/problem/P2671" target="_blank" rel="noopener">题目</a></h1><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><ol>
<li>三元组，可以看出x与z的关系，同颜色，以及同奇或同偶数</li>
<li>在每个颜色的基础上，再分奇数偶数组，分开计算</li>
<li>通过计算过程可知，可以用前缀和的方式简化计算</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class P2671求和 {

    static int n,m;
    static int s[][],sum[][];
    static int c[],x[];
    public static void main(String[] args) throws IOException {
        n=nextInt();m=nextInt();
        x=new int[n+1];c=new int[n+1];
        s=new int[m+1][2];sum=new int[n+1][2];
        for (int i =1; i &lt;=n; i++)x[i]=nextInt();
        for (int i =1; i &lt;=n; i++) {
            c[i]=nextInt();
      s[c[i]][i%2]++;//每个颜色编号奇偶数量
            sum[c[i]][i%2]=(sum[c[i]][i%2]+x[i])%10007;//累加
        }
        int ans=0;
        for (int i =1; i &lt;=n; i++) {//计算取模
            ans=(ans+i*((s[c[i]][i%2]-2)*x[i]%10007+sum[c[i]][i%2]))%10007;
        }
        System.out.println(ans);
    }
    public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in),32768));
    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    public static double nextDouble() throws IOException{ in.nextToken(); return in.nval; }
    public static float nextFloat() throws IOException{ in.nextToken(); return (float)in.nval; }
    public static int nextInt() throws IOException{ in.nextToken(); return (int)in.nval; }
    public static String next() throws IOException{ in.nextToken(); return in.sval;}

}</code></pre>]]></content>
      <categories>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>2019</title>
    <url>/2020/03/25/Problem/2019/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://ac.nowcoder.com/acm/contest/1099/I" target="_blank" rel="noopener">题目</a></h1><p>Bobo 有一颗 n 个点的树，点的编号是 1, 2, \dots, n1,2,…,n. 树有 (n - 1) 条边，第 i 条边的端点是 a_i和 b_i权值是 c_i. 求满足 u &lt; v ，并且点 u 到点 v 路径上的权值和是 2019 的倍数，的 (u, v) 数量。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><blockquote>
<p>裸的点分治</p>
</blockquote>
<ol>
<li>每次点分治时，先从该区域的中心开始（重心）//减少时间复杂度</li>
<li>（u,v）的数量等于每个点的计算-重复计算的</li>
<li>路径为0的数量单独计算</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.util.Arrays;
import java.util.Scanner;

public class Main{

    public static class edg{ //邻接表
        private int to;
        private int next;
        private int v;
        public edg() {

        }
        public edg(int to,int next,int v) {
            this.next=next;
            this.to=to;
            this.v=v;
        }
    }

    static int n;
    static int head[],cent=0;
    static edg a[];
    static int t[],d[],cnt;
    static boolean vis[];
    static int size[],f[];
    static int Tsize,root=0;
    static int ans=0;
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        head=new int[20001];a=new edg[40002];f=new int[20001];
        size=new int[20001];d=new int[20001];
        t=new int[2020];vis=new boolean[20001];
        while(sc.hasNext()) {
        n=sc.nextInt();Arrays.fill(vis,false);
        Arrays.fill(head, -1);cent=0;
        for (int i = 1; i &lt;n; i++) {
            int x=sc.nextInt();
            int y=sc.nextInt();
            int z=sc.nextInt();
            add(x,y,z);
        }
        root=0;ans=0;Arrays.fill(f,0);
        Tsize=n;f[0]=Integer.MAX_VALUE ;
        getroot(1,0);Dfs(root);
        System.out.println(ans);
     }
    }
    public static void Dfs(int u) {//点分治
        ans+=calc(u,0);//一前一后
        vis[u]=true;
        for (int i =head[u]; i!=-1;i=a[i].next) {
            int v=a[i].to;
            if(vis[v])continue;
            ans-=calc(v,a[i].v);
            root=0;Tsize=size[v];
            getroot(v,0);
            Dfs(root);
        }
    }
    public static int calc(int u,int D) {//计算分治结果
     for(int i=0;i&lt;2019;i++)t[i]=0;
        d[u]=D%2019;
        dfs(u,0);int p=0;
     for(int i=1;i&lt;=1009;i++)p+=t[i]*t[(2019-i)%2019];//有顺序
      p+=t[0]*(t[0]-1)/2;
        return p;
    }
    public static void dfs(int u,int fa) {//计算路径数量
        t[d[u]]++;
        for (int i =head[u]; i!=-1; i=a[i].next) {
            int v=a[i].to;
            if(vis[v]||v==fa)continue;
            d[v]=(d[u]+a[i].v)%2019;
            dfs(v,u);
        }
    }
    public static void getroot(int u,int fa) {//寻找重心
        size[u]=1;f[u]=0;
        for (int i =head[u]; i!=-1;i=a[i].next) {
             int v=a[i].to;
             if(vis[v]||v==fa)continue;
             getroot(v,u);
             size[u]+=size[v];
             f[u]=Math.max(f[u], size[v]);
        }
        f[u]=Math.max(f[u],Tsize-size[u]);
        if(f[u]&lt;f[root])root=u;
    }
    public static void add(int x,int y,int z) {
        a[cent]=new edg(y,head[x],z);
        head[x]=cent++;
        a[cent]=new edg(x,head[y],z);
        head[y]=cent++;
    }
}</code></pre>]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>2019省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>A*与IDA*学习笔记</title>
    <url>/2020/03/24/blog/A_Star/</url>
    <content><![CDATA[<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h1><blockquote>
<p>带有迭代加深和估价函数优化的dfs搜索</p>
</blockquote>
<h2 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h2><blockquote>
<p>每次限定一个<strong>maxdepmaxdep</strong>最大深度，使搜索树的深度不超过<strong>maxdepmaxdep</strong></p>
</blockquote>
<pre><code>for(R int maxdep=1;maxdep&lt;=题目中给的最大步数;maxdep++){
      dfs(0,maxdep);//0为出入函数中当前步数，maxdep为传入的最大深度。
      if(success)break;//如果搜索成功则会在dfs函数中将success赋值为1。
  }</code></pre><h2 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h2><h3 id="定义：-f-n-g-n-h-n"><a href="#定义：-f-n-g-n-h-n" class="headerlink" title="定义： f(n)=g(n)+h(n)"></a>定义： f(n)=g(n)+h(n)</h3><blockquote>
<p>其中f(n)f(n)是节点的估价函数，g(n)g(n)是现在的实际步数，h(n)h(n)是对未来步数的最完美估价</p>
</blockquote>
<pre><code>void dfs(int dep,int maxdep){
if(evaluate()+dep&gt;maxdep)return;------</code></pre><hr>
<h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><blockquote>
<p>这是一种搜索算法,属于启发式搜索中的一种.具体属于对bfs+优先队列的优化,可利用估价函数来优化</p>
</blockquote>
<h2 id="估价函数-1"><a href="#估价函数-1" class="headerlink" title="估价函数"></a>估价函数</h2><p>同上，一般都是反向跑一遍求出每个点的最佳的估价函数。  </p>
<p>在优先队列中，以每个状态的F值为第一关键字。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2020/03/19/blog/git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><pre><code>mkdir &lt;文件夹名称&gt; # 创建文件夹
cd &lt;文件夹名称&gt; # 进入文件夹
cat &lt;文件名称&gt; # 查看文件内容
rm &lt;文件名称&gt; # 删除文件</code></pre><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><blockquote>
<p>在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
</blockquote>
<pre><code>git add &lt;文件名称&gt; # 把文件的修改提交的暂存区，可反复多次使用，添加多个文件
git commit -m &quot;此次提交的说明注释&quot; # 把暂存区的修改提交到版本库中
git status # 可以让我们时刻掌握仓库当前的状态
git diff # 可以查看工作区和暂存区修改的不同
git diff HEAD -- &lt;文件名&gt; # 查看工作区和仓库的差异
git log  --pretty=oneline  # 显示从最近到最远的提交日志，版本记录，按“Q”键退出
git reset --hard HEAD^ # 版本回退
git reflog # 用来记录你的每一次命令
git rm &lt;文件名称&gt; # 删除文件的修改到暂存区，之后commit就行
git checkout -- &lt;filename&gt; # 把文件在工作区或暂存区的修改全部撤销
git checkout -b &lt;name&gt; # 表示创建并切换当前分支
git branch # 会列出所有分支，当前分支前面会标一个*号
git merge &lt;name&gt; # 用于合并指定分支到当前分支
git branch -d &lt;name&gt; #删除指定分支
git log --graph # 可以看到分支合并图
git merge --no-ff -m &quot;merge with no-ff&quot; &lt;name&gt; #合并时禁用Fast forward模式加上-m参数，把commit描述写进去
git stash # 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
git stash list # 可以看到被存的工作现场
git stash apply &lt;name&gt; # 恢复工作现场，但是恢复后，stash内容并不删除
git stash drop &lt;name&gt; # 删除list中的指定的工作现场记录
git stash pop # 恢复的同时把stash内容也删了
git cherry-pick &lt;commit&gt; # 让我们能复制一个特定的提交到当前分支
git branch -D &lt;name&gt; # 强行删除某个分支
git remote -v # 可以查看当前关联的远程库
git push origin &lt;name&gt; # 推送指定分支
git checkout -b &lt;name&gt; origin/&lt;name&gt; # 创建并切换关联远程库的指定分支
git pull # 最新的提交从远程库抓下来，然后，在本地合并
git branch --set-upstream-to=origin/&lt;name&gt; &lt;name&gt; #将远程库的分支与本地库关联</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
<li>版本号没必要写全，前几位就可以了，Git会自动去找</li>
</ol>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><blockquote>
<p>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</p>
</blockquote>
<ol>
<li>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>
<li>每次修改，如果不用git add到暂存区，那就不会加入到commit中。</li>
</ol>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：<br>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<hr>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p><strong>在工作区</strong>就<code>rm &lt;filename&gt;</code>.</p>
<p>确实要<strong>从版本库中删除该文件</strong>，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>。</p>
<p><strong>删错了</strong>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><blockquote>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
</blockquote>
<ol>
<li><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code></p>
</li>
<li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容<br>3</p>
</li>
<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改</p>
</li>
</ol>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><blockquote>
<p>Git鼓励大量使用分支</p>
</blockquote>
<p>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><blockquote>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward模式</code>，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用<code>Fast forward模式</code>，<code>Git</code>就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</p>
</blockquote>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><blockquote>
<p>如果需要离开现在的工作现场（还没提交），先把工作现场<code>git stash</code>一下</p>
</blockquote>
<p>修复bug时，我们会通过创建新的<code>bug分支</code>进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复<strong>bug</strong>，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><blockquote>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin</p>
</blockquote>
<p><strong>多人协作的工作模式：</strong></p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<hr>
<p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；  </p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git基础</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP</title>
    <url>/2020/03/08/blog/dp/</url>
    <content><![CDATA[<h1 id="状态1的个数"><a href="#状态1的个数" class="headerlink" title="状态1的个数"></a>状态1的个数</h1><pre><code>int Count(int x) { //含义见上
    int ans = 0;
    while(x) x &amp;= (x - 1), ++ans;
    return ans;
}   </code></pre>]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LCT学习笔记</title>
    <url>/2020/02/26/blog/%E6%B5%85%E8%B0%88LCT/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>链剖分，是指一类对树的边进行轻重划分的操作，这样做的目的是为了减少某些链上的修改、查询等操作的复杂度。目前总共有三类：重链剖分，实链剖分和并不常见的长链剖分.</p>
</blockquote>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol>
<li>每一个Splay维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历Splay得到的每个点的深度序列严格递增。</li>
<li>每个节点包含且仅包含于一个Splay中。</li>
<li>边分为实边和虚边，实边包含在Splay中，而虚边总是由一棵Splay指向另一个节点（指向该Splay中中序遍历最靠前的点在原树中的父亲）。<br>因为性质2，当某点在原树中有多个儿子时，只能向其中一个儿子拉一条实链（只认一个儿子），而其它儿子是不能在这个Splay中的。<br>那么为了保持树的形状，我们要让到其它儿子的边变为虚边，由对应儿子所属的Splay的根节点的父亲指向该点，而从该点并不能直接访问该儿子（认父不认子）。</li>
</ol>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a><a href="https://www.luogu.com.cn/problem/P3690" target="_blank" rel="noopener">模板</a></h2><h2 id="学习资料-总结应用-相关题目"><a href="#学习资料-总结应用-相关题目" class="headerlink" title="学习资料 总结应用  相关题目"></a>学习资料 <a href="https://www.cnblogs.com/flashhu/p/9498517.html" target="_blank" rel="noopener">总结应用</a>  <a href="https://www.zybuluo.com/xzyxzy/note/1027479" target="_blank" rel="noopener">相关题目</a></h2><h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><pre><code>static int v[],s[];//权值和所在点的异或值
static int fa[],r[];//父亲节点和是否需要旋转
static int ch[][];//子节点
static int hep[];//用于垃圾回收
static int cent=0;//记录下标</code></pre><h1 id="各种操作"><a href="#各种操作" class="headerlink" title="各种操作"></a>各种操作</h1><h2 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h2><h3 id="filp-int-x"><a href="#filp-int-x" class="headerlink" title="filp(int x)"></a>filp(int x)</h3><blockquote>
<p>反转操作</p>
</blockquote>
<pre><code>public static void filp(int x){
  r[x]^=1;
  int k=ch[x][0];ch[x][0]=ch[x][1];
  ch[x][1]=k;
}</code></pre><h3 id="pushup-int-x"><a href="#pushup-int-x" class="headerlink" title="pushup(int x)"></a>pushup(int x)</h3><blockquote>
<p>更新操作</p>
</blockquote>
<pre><code>public static void pushup(int x){
  s[x]=s[ch[x][1]]^s[ch[x][0]]^v[x];
}</code></pre><h3 id="get-int-x"><a href="#get-int-x" class="headerlink" title="get(int x)"></a>get(int x)</h3><blockquote>
<p>判断是否有父亲节点</p>
</blockquote>
<pre><code>public static boolean get(int x){
  if(ch[fa[x]][0]==x||ch[fa[x]][1]==x){
    return true;
  }else{
    return false;
  }
}</code></pre><h3 id="rotate-int-x"><a href="#rotate-int-x" class="headerlink" title="rotate(int x)"></a>rotate(int x)</h3><blockquote>
<p>基操</p>
</blockquote>
<pre><code>public static void rotate(int x){
  int y=fa[x],z=fa[y],k=ch[y][1]==x?1:0;
  int w=ch[x][k^1];
  if(get(y))ch[z][ch[z][1]==y?1:0]=x;
  ch[x][k^1]=y;ch[y][k]=w;
  if(w!=0)fa[w]=y;
  fa[x]=z;fa[y]=x;
  pushup(y);pushup(x);
}</code></pre><h2 id="access-x"><a href="#access-x" class="headerlink" title="access(x)"></a>access(x)</h2><blockquote>
<p>access即定义为打通根节点到指定节点的实链，使得一条中序遍历以根开始、以指定点结束的Splay出现. (注意根节点为所连接的深度最小的点)</p>
</blockquote>
<pre><code>public static void Access(int x){
  for (int y = 0;x!=0;y=x,x=fa[x]) {
    splay(x);ch[x][1]=y;pushup(x);
  }
}</code></pre><h2 id="makeroot-x"><a href="#makeroot-x" class="headerlink" title="makeroot(x)"></a>makeroot(x)</h2><blockquote>
<p>利用到access(x)和Splay的翻转操作。</p>
</blockquote>
<pre><code>public static void makeRoot(int x){
        Access(x);splay(x);filp(x);
    }</code></pre><h2 id="findroot-x"><a href="#findroot-x" class="headerlink" title="findroot(x)"></a>findroot(x)</h2><blockquote>
<p>找x所在原树的树根，主要用来判断两点之间的连通性（findroot(x)==findroot(y)表明x,y在同一棵树中）</p>
</blockquote>
<pre><code>public static int findRoot(int x){
  Access(x);splay(x);
  while(ch[x][0]!=0){pushdown(x);x=ch[x][0];}
  //splay(x)保持复杂度，诡。
  return x;
}</code></pre><h2 id="split-x-y"><a href="#split-x-y" class="headerlink" title="split(x,y)"></a>split(x,y)</h2><blockquote>
<p>定义为拉出x−y的路径成为一个Splay（本蒟蒻以y作为该Splay的根）</p>
</blockquote>
<pre><code>public static void split(int x,int y){
  makeRoot(x);Access(y);splay(y);
}</code></pre><h2 id="link-x-y"><a href="#link-x-y" class="headerlink" title="link(x,y)"></a>link(x,y)</h2><blockquote>
<p>连一条x−y的边（本蒟蒻使x的父亲指向y，连一条轻边）</p>
</blockquote>
<pre><code>public static void link(int x,int y){
  makeRoot(x);if(findRoot(y)!=x)fa[x]=y;
}</code></pre><h2 id="cut-x-y"><a href="#cut-x-y" class="headerlink" title="cut(x,y)"></a>cut(x,y)</h2><blockquote>
<p>将x−y的边断开。注意合法性。</p>
</blockquote>
<pre><code>public static void cut(int x,int y){
  split(x,y);
  if(findRoot(y)==x&amp;&amp;fa[x]==y&amp;&amp;ch[x][1]==0){
    fa[x]=0;ch[y][0]=0;
    pushup(y);
  }return ;
}</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>public class 模板{
    static int v[],s[];
    static int fa[],r[];
    static int ch[][];
    static int hep[];
    static int cent=0;
    public static void main(String[] args) throws IOException {
        StringBuilder sb = new StringBuilder();//输出
        int n=nextInt();int m=nextInt();
        v=new int[n+1];s=new int[n+1];
        fa=new int[n+1];r=new int[n+1];
        ch=new int[n+1][2];hep=new int[500000];
        for (int i =1; i &lt;=n; i++) {
            v[i]=nextInt();
        }
        for (int i = 0; i &lt;m; i++) {
            int d=nextInt();
            int x=nextInt(),y=nextInt();
            if(d==0){
                split(x,y);sb.append(s[y]+&quot;\n&quot;);
            }else if(d==1){
                link(x,y);
            }else if(d==2){
                cut(x,y);
            }else{
                splay(x);v[x]=y;
            }
        }
        System.out.println(sb);
    }
    public static void cut(int x,int y){
        split(x,y);
        if(findRoot(y)==x&amp;&amp;fa[x]==y&amp;&amp;ch[x][1]==0){
            fa[x]=0;ch[y][0]=0;
            pushup(y);
        }return ;
    }
    public static void link(int x,int y){
        makeRoot(x);if(findRoot(y)!=x)fa[x]=y;
    }
    public static void split(int x,int y){
        makeRoot(x);Access(y);splay(y);
    }
    public static int findRoot(int x){
        Access(x);splay(x);
        while(ch[x][0]!=0){pushdown(x);x=ch[x][0];}
        return x;
    }
    public static void makeRoot(int x){
        Access(x);splay(x);filp(x);
    }
    public static void Access(int x){
        for (int y = 0;x!=0;y=x,x=fa[x]) {
            splay(x);ch[x][1]=y;pushup(x);
        }
    }
    public static void splay(int x){
        int y=x;cent=0;hep[++cent]=y;
        while(get(y)){hep[++cent]=fa[y];y=fa[y];}
        while(cent!=0)pushdown(hep[cent--]);
        while(get(x)){
            y=fa[x];cent=fa[y];
            if(get(y))rotate((ch[y][0]==x)==(ch[cent][0]==y)?y:x);
                rotate(x);
        }pushup(x);return ;
    }
    public static void rotate(int x){
        int y=fa[x],z=fa[y],k=ch[y][1]==x?1:0;
        int w=ch[x][k^1];
        if(get(y))ch[z][ch[z][1]==y?1:0]=x;
        ch[x][k^1]=y;ch[y][k]=w;
        if(w!=0)fa[w]=y;
        fa[x]=z;fa[y]=x;
        pushup(y);pushup(x);
    }
    public static void pushdown(int x){
        if(r[x]==0)return;
        r[x]=0;
        if(ch[x][1]!=0)filp(ch[x][1]);
        if(ch[x][0]!=0)filp(ch[x][0]);
    }
    public static void filp(int x){
        r[x]^=1;
        int k=ch[x][0];ch[x][0]=ch[x][1];
        ch[x][1]=k;
    }
    public static void pushup(int x){
        s[x]=s[ch[x][1]]^s[ch[x][0]]^v[x];
    }
    public static boolean get(int x){
        if(ch[fa[x]][0]==x||ch[fa[x]][1]==x){
            return true;
        }else{
            return false;
        }
    }
    public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in),32768));
    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

    public static double nextDouble() throws IOException{ in.nextToken(); return in.nval; }
    public static float nextFloat() throws IOException{ in.nextToken(); return (float)in.nval; }
    public static int nextInt() throws IOException{ in.nextToken(); return (int)in.nval; }
    public static String next() throws IOException{ in.nextToken(); return in.sval;}

}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>书架</title>
    <url>/2020/01/01/life/%E4%B9%A6%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="2018年"><a href="#2018年" class="headerlink" title="2018年"></a>2018年</h1><h2 id="凯文·凯利三部曲"><a href="#凯文·凯利三部曲" class="headerlink" title="凯文·凯利三部曲"></a>凯文·凯利三部曲</h2><blockquote>
<p>刚开始步入大学生活的我，读的第一本关于时代发展的书《失控》。</p>
</blockquote>
<h3 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h3><h4 id="《失控》"><a href="#《失控》" class="headerlink" title="《失控》"></a>《失控》</h4><h2 id="《香农传》"><a href="#《香农传》" class="headerlink" title="《香农传》"></a>《香农传》</h2><h2 id="《信息简史》"><a href="#《信息简史》" class="headerlink" title="《信息简史》"></a>《信息简史》</h2><h2 id="《复利效应》"><a href="#《复利效应》" class="headerlink" title="《复利效应》"></a>《复利效应》</h2>]]></content>
      <categories>
        <category>历史记录</category>
      </categories>
      <tags>
        <tag>书架</tag>
      </tags>
  </entry>
  <entry>
    <title>替罪羊树学习笔记</title>
    <url>/2019/12/12/blog/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>一种基于部分重建的自平衡二叉搜索树。替罪羊树的主要思想就是将不平衡的树压成一个序列,然后暴力重构成一颗平衡的树。</p>
</blockquote>
<p>&emsp;&emsp;这里的平衡指的是：对于某个 <code>0.5&lt;=alpha&lt;=1</code>满足 <code>size( Lson(x) )&lt;=alpha*size(x) 并且 size( Rson(x) )&lt;=alpha*size(x)</code>,即这个节点的两棵子树的 size 都不超过以该节点为根的子树的 size，那么就称这个子树(或节点)是平衡的, alpha 最好不要选 0.5 ，容易T飞，一般选 0.75 就挺好的。而我就选择了0.8。<br>&emsp;&emsp;相较于splay这样选择维护平衡的操作，替罪羊树的维护就简单粗暴多了。</p>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ol>
<li>一个数一个值，相同的数也往左儿子那边放，至于为什么存在一个节点里，是因为暴力构树不好操作（二分）.</li>
</ol>
<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><pre><code>static int m;//操作次数
static double alp=0.8;//常量
static int mem[],pool=0;//垃圾回收数组和配套指针
static int val[];//节点数值
static int size[],tot[];
static int son[][];
static boolean real[];
static int root=0,cnt=0;
static int poi=0,cur[];
static int tob=0;</code></pre><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;通过重建树的方式让其他操作更加简单实现,常规操作跟splay差不多，核心在于重建树的代码，如把那些不存在的点更新去掉等。</p>
<h1 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

public class 替罪羊模板 {
    static int m;
    static double alp=0.8;
    static int mem[],pool=0;
    static int val[];
    static int size[],tot[];
    static int son[][];
    static boolean real[];
    static int root=0,cnt=0;
    static int poi=0,cur[];
    static int tob=0;
    public static void main(String[] args) throws IOException {
        Input in = new Input();StringBuilder sb = new StringBuilder();
        mem=new int[100001];
        for (int i =100000; i&gt;0; i--) mem[++pool]=i;
        m=in.nextInt();
        size=new int[m+2];tot=new int[m+2];
        son=new int[m+2][2];val=new int[m+2];
        cur=new int[m+2];real=new boolean[m+2];
        int pot,x;
        while(m--&gt;0) {
            pot=in.nextInt();x=in.nextInt();
            switch(pot){
            case 1:insert(0,1,root,x);if(isbad(root))rebuild(0,0,root);break;//删除
            case 2:del_val(x);break;//删除
            case 3:sb.append(get_rk(x)+&quot;\n&quot;);break;//某数的排名
            case 4:sb.append(get_kth(x)+&quot;\n&quot;);break;//排名第几位的数值
            case 5:sb.append(get_kth(get_rk(x)-1)+&quot;\n&quot;);break;//前驱
            case 6:sb.append(get_kth(get_rk(x+1))+&quot;\n&quot;);break;//后续
            }
        }
        System.out.println(sb);
    }
    public static int get_kth(int x) {//某个排名对应的值；
        int now=root;
        while(now&gt;0) {
            if(!real[now]&amp;&amp;(size[son[now][0]]+1==x)) {
                return val[now];
            }else if(size[son[now][0]]&gt;=x) {
                now=son[now][0];
            }else {
                x-=size[son[now][0]]+(real[now]?0:1);
                now=son[now][1];
            }
        }
        return 0;
    }
    public static void del_pos(int u,int y) {//删除标记某个数
        if(!real[u]&amp;&amp;(size[son[u][0]]+1==y)) {
            real[u]=true;size[u]--;return;
        }
        size[u]--;
        if(size[son[u][0]]+(real[u]?0:1)&gt;=y) {
            del_pos(son[u][0],y);
        }else {
            del_pos(son[u][1],y-(size[son[u][0]]+(real[u]?0:1)));
        }
    }
    public static int get_rk(int x) {//某个数的排名
        int now=root,ret=1;
        while(now!=0) {
            if(val[now]&gt;=x) {
                now=son[now][0];
            }else {
                ret+=size[son[now][0]]+(real[now]?0:1);
                now=son[now][1];
            }
        }
        return ret;
    }
    public static void del_val(int x) {//删除某个值
        del_pos(root,get_rk(x));
        if(1.0*tot[root]*alp&gt;size[root]) {
            rebuild(0,0,root);
        }
    }
    public static void insert(int fa,int d,int u,int x) {//插入节点
        if(u==0) {
            u=mem[pool--];val[u]=x;real[u]=false;
            tot[u]=1;size[u]=1;son[u][1]=0;son[u][0]=0;
            if(fa==0) {
                root=u;
            }else {
                son[fa][d]=u;
            }
            return;
        }
        tot[u]++;size[u]++;
        if(val[u]&gt;=x) {
            insert(u,0,son[u][0],x);
        }else { insert(u,1,son[u][1],x);}
        boolean flag=isbad(u);
        if(!flag&amp;&amp;tob&gt;0) { //通过有层次的递归判断是否需要重建树，减少运算
            if(son[u][0]==tob) {
                rebuild(u,0,son[u][0]);
            }else {
                rebuild(u,1,son[u][1]);
            }
            tob=0;
        }else if(flag) {
            tob=u;
        }
    }
    public static void rebuild(int fa,int d,int x) {//重建树
        poi=0;dfs(x);
        int mid=(1+poi)&gt;&gt;1;x=cur[mid];
        if(poi&gt;0)build(fa,d,x,1,poi);
        if(fa==0) {
            root=x;
        }else {
            son[fa][d]=x;
        }
    }
    public static boolean isbad(int x) {//是不是不平衡
        if(1.0*size[x]*alp&lt;=(double)Math.max(size[son[x][1]],size[son[x][0]]))return true;
        return false;
    }
    public static void dfs(int x) {//中序遍历存节点
        if(x==0)return;
        dfs(son[x][0]);
        if(!real[x]) {
            cur[++poi]=x;
        }else {
            mem[++pool]=x;
        }
        dfs(son[x][1]);
    }
    public static void build(int fa,int d,int x,int L,int R) {//二分建树
        int mid=(L+R)&gt;&gt;1;x=cur[mid];
        if(L==R) {
            son[x][0]=0;son[x][1]=0;
            size[x]=1;tot[x]=1;return;
        }
        if(L&lt;mid){
            son[x][0]=cur[(L+mid-1)&gt;&gt;1];
            build(x,0,son[x][0],L,mid-1);
        }else {
            son[x][0]=0;
        }
        build(x,1,son[x][1],mid+1,R);son[x][1]=cur[(mid+R+1)&gt;&gt;1];
        tot[x]=tot[son[x][1]]+tot[son[x][0]]+1;
        size[x]=size[son[x][1]]+size[son[x][0]]+1;
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>替罪羊树</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay学习笔记</title>
    <url>/2019/12/11/blog/Splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>伸展树（Splay）是一种平衡二叉树，即优化后的二叉查找树。伸展树可以自我调整，这就要依靠伸展操作Splay(x,S)，使得提升效率。</p>
</blockquote>
<p>&emsp;&emsp;假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。splay tree应运而生。splay tree是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</p>
<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><pre><code>size[]:自身和子树大小
num[]:该节点的数量(重复的值的个数)
val[]:权值
fa[]:父亲节点
son[][2]:左右子节点
root=0:总节点
cent=0:记录节点编号</code></pre><h1 id="各种操作"><a href="#各种操作" class="headerlink" title="各种操作"></a>各种操作</h1><h2 id="chk操作"><a href="#chk操作" class="headerlink" title="chk操作"></a>chk操作</h2><blockquote>
<p>辅助操作，查询节点是它父节点的左或右儿子。</p>
</blockquote>
<pre><code>return son[fa[x]][1]==x?1:0;</code></pre><h2 id="pushup操作"><a href="#pushup操作" class="headerlink" title="pushup操作"></a>pushup操作</h2><blockquote>
<p>辅助操作，更新size数组的值。</p>
</blockquote>
<pre><code>size[x]=num[x]+size[son[x][1]]+size[son[x][0]];</code></pre><h2 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate(旋转)"></a>rotate(旋转)</h2><blockquote>
<p>自然语言是多么的无力,请见代码</p>
</blockquote>
<pre><code>if(x==root)return;
int y=fa[x],z=fa[y],k=chk(x),w=son[x][k^1];//父亲和祖父节点，以及x相反的儿子
son[z][chk(y)]=x;fa[x]=z;
son[y][k]=w;fa[w]=y;
son[x][k^1]=y;fa[y]=x;
pushup(y);pushup(x);</code></pre><h2 id="splay伸展（核心）"><a href="#splay伸展（核心）" class="headerlink" title="splay伸展（核心）"></a>splay伸展（核心）</h2><blockquote>
<p><strong>将一个节点一路rotate到指定节点的儿子。</strong>如果该节点、该父节点和该爷爷节点「三点一线」，那么应该先旋转父节点。</p>
</blockquote>
<pre><code>public static void splay(int x,int goal) {
         if(x==0)return;
         while(fa[x]!=goal) {//不是指定节点
            int y=fa[x],z=fa[y];
             if(z!=goal) {
                 if(chk(x)==chk(y)) {//如果三点一线
                     rotate(y);
                 }else {
                     rotate(x);
                 }
             }
             rotate(x);
         }
         if(goal==0)root=x;//如果移动到根节点（fa[root]=0）
     }</code></pre><h2 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h2><blockquote>
<p>辅助操作，将<strong>最大的小于等于的数</strong>所在的节点splay到根。</p>
</blockquote>
<pre><code>if(root==0)return;
int cur=root;int d=val[cur]&lt;x?1:0;
while(son[cur][d]!=0&amp;&amp;val[cur]!=x) {
    cur=son[cur][d];d=val[cur]&lt;x?1:0;
}
splay(cur,0);</code></pre><h2 id="插入（insert）操作"><a href="#插入（insert）操作" class="headerlink" title="插入（insert）操作"></a>插入（insert）操作</h2><blockquote>
<p>从根节点开始，一路搜索下去。如果节点存在则直接自增cnt的值。否则新建节点并与父节点连边。</p>
</blockquote>
<p>因为新建节点时可能会拉出一条链，所以新建节点后需要将该节点splay到根节点。沿途的rotate操作可以使平衡树恢复平衡。</p>
<pre><code>public static void insert(int x) {//插入
        int cur=root,d=0;
        while(cur!=0&amp;&amp;val[cur]!=x) {//往下寻找这个数的位置
            d=cur;cur=son[cur][x&gt;val[cur]?1:0];
        }
        if(cur!=0) {//如果不是新数
            num[cur]++;
        }else {//如果是的话就新建一个节点。
            cur=++cent;
            if(d!=0)son[d][x&gt;val[d]?1:0]=cur;//父亲节点是真实节点
            fa[cur]=d;size[cur]=1;num[cur]=1;
            val[cur]=x;
        }
        splay(cur,0);
    }</code></pre><h2 id="查询-kth"><a href="#查询-kth" class="headerlink" title="查询(kth)"></a>查询(kth)</h2><blockquote>
<p>查询排名为k的数（从小到大）。从根节点开始，一路搜索下去。每次判断要走向哪个子树。注意考虑重复权值。</p>
</blockquote>
<pre><code>public static int kth(int k) {
  int cur=root;
  while(true) {
    if(son[cur][0]!=0&amp;&amp;k&lt;=size[son[cur][0]]) {//在左边
      cur=son[cur][0];
    }else if(son[cur][1]!=0&amp;&amp;k&gt;size[son[cur][0]]+num[cur] ){//在右边
      k-=size[son[cur][0]]+num[cur];
      cur=son[cur][1];
    }else { return cur;     }
  }
}</code></pre><h2 id="前驱-pre-与后继-succ"><a href="#前驱-pre-与后继-succ" class="headerlink" title="前驱(pre)与后继(succ)"></a>前驱(pre)与后继(succ)</h2><blockquote>
<p>定义: 在序列中，比某数小但最大的数和比某数大但却最小的数。将该节点（x）find到根后，根据性质就能找到。</p>
</blockquote>
<p><strong>注意</strong>，为防止没有前驱或者后继的情况下，事先在树中insert一个<strong>极大</strong>节点和一个<strong>极小</strong>节点。但在操作的时候要注意这两个节点的存在。</p>
<pre><code>public static int pre(int x) {//前驱
        find(x);
        if(val[root]&lt;x)return root;
        int cur=son[root][0];
        while(son[cur][1]!=0) cur=son[cur][1];
        return  cur;
    }
  public static int succ(int x) {//后续
          find(x);
          if(val[root]&gt;x) return root;
          int cur=son[root][1];
          while(son[cur][0]!=0) cur=son[cur][0];
          return cur;
      }</code></pre><h2 id="查询rank-rank"><a href="#查询rank-rank" class="headerlink" title="查询rank(rank)"></a>查询rank(rank)</h2><blockquote>
<p>查询某数的排名（从小到大）。并不需要专门写操作。将该节点find到根后返回左子树的权值数即可。(极小点也考虑进去了)</p>
</blockquote>
<pre><code>find(x);
sb.append((size[son[root][0]])+&quot;\n&quot;);</code></pre><h2 id="区间反转"><a href="#区间反转" class="headerlink" title="区间反转"></a>区间反转</h2><blockquote>
<p>向线段树打标记一样。打标记时，将和分别旋转到根节点和根节点右儿子处，那么的左子树即是区间。在其根处打上标记然后在查询大和输出中序遍历时下传标记即可。</p>
</blockquote>
<p><strong>注意</strong>，splay维持的性质左小右大是插入时认为的值。区间反转之后不影响。</p>
<h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Scanner;

public class 模板 {
    static int size[]; //包括自身子树大小
    static int num[];//该节点的数量
    static int val[];//权值
    static int fa[];//父亲节点
    static int son[][];
    static int root=0,cent=0;//
    static StringBuilder sb;
    public static void main(String[] args) throws IOException {
        Input in = new Input();sb = new StringBuilder();
        int n=in.nextInt();
        size=new int[n+2];num=new int[n+2];
        val=new int[n+2];fa=new int[n+2];
        son=new int[n+2][2];
        insert(Integer.MIN_VALUE);
        insert(Integer.MAX_VALUE);
        for (int i = 0; i &lt;n; i++) {
            int d=in.nextInt(),x=in.nextInt();
            switch(d) {
            case 1: insert(x);break;
            case 2:remove(x);break;
            case 3:rank(x);break;//排名
            case 4:sb.append(val[kth(x+1)]+&quot;\n&quot;);break;//排名为x的数
            case 5:sb.append(val[pre(x)]+&quot;\n&quot;);break;//前驱
            case 6:sb.append(val[succ(x)]+&quot;\n&quot;);break;//后续
            }
        }
       System.out.println(sb);
    }
    public static void insert(int x) {//插入
        int cur=root,d=0;
        while(cur!=0&amp;&amp;val[cur]!=x) {//往下寻找这个数的位置
            d=cur;cur=son[cur][x&gt;val[cur]?1:0];
        }
        if(cur!=0) {//如果不是新数
            num[cur]++;
        }else {//如果是的话就新建一个节点。
            cur=++cent;
            if(d!=0)son[d][x&gt;val[d]?1:0]=cur;//父亲节点是真实节点
            fa[cur]=d;size[cur]=1;num[cur]=1;
            val[cur]=x;
        }
        splay(cur,0);
    }
    public static int kth(int k) {
        int cur=root;
        while(true) {
            if(son[cur][0]!=0&amp;&amp;k&lt;=size[son[cur][0]]) {
                cur=son[cur][0];
            }else if(son[cur][1]!=0&amp;&amp;k&gt;size[son[cur][0]]+num[cur] ){
                k-=size[son[cur][0]]+num[cur];
                cur=son[cur][1];
            }else { return cur;     }
        }
    }
    public static int pre(int x) {//前驱
        find(x);
        if(val[root]&lt;x)return root;
        int cur=son[root][0];
        while(son[cur][1]!=0) cur=son[cur][1];
        return  cur;
    }
    public static int succ(int x) {//后续
        find(x);
        if(val[root]&gt;x) return root;
        int cur=son[root][1];
        while(son[cur][0]!=0) cur=son[cur][0];
        return cur;
    }
    public static void remove(int x) {//删除
        int last=pre(x);int next=succ(x);
        splay(last,0);splay(next,last);
        int del=son[next][0];
        if(num[del]&gt;1) {
            num[del]--;
            splay(del,0);
        }else {
            son[next][0]=0;
        }
    }
    public static void rank(int x) {//查询
        find(x);
        sb.append((size[son[root][0]])+&quot;\n&quot;);
    }
    public static void find(int x) {
        if(root==0)return;
        int cur=root;int d=val[cur]&lt;x?1:0;
        while(son[cur][d]!=0&amp;&amp;val[cur]!=x) {
            cur=son[cur][d];d=val[cur]&lt;x?1:0;
        }
        splay(cur,0);
    }
     public static void splay(int x,int goal) {
         if(x==0)return;
         while(fa[x]!=goal) {
            int y=fa[x],z=fa[y];
             if(z!=goal) {
                 if(chk(x)==chk(y)) {
                     rotate(y);
                 }else {
                     rotate(x);
                 }
             }
             rotate(x);
         }
         if(goal==0)root=x;
     }
    public static void rotate(int x) {//旋转
        if(x==root)return;
        int y=fa[x],z=fa[y],k=chk(x),w=son[x][k^1];//父亲和祖父节点，以及x相反的儿子
        son[z][chk(y)]=x;fa[x]=z;
        son[y][k]=w;fa[w]=y;
        son[x][k^1]=y;fa[y]=x;
        pushup(y);pushup(x);
    }
    public static void pushup(int x) {
        size[x]=num[x]+size[son[x][1]]+size[son[x][0]];
    }
    public static int chk(int x) {
        return son[fa[x]][1]==x?1:0;
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Splay</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>三维偏序</title>
    <url>/2019/12/09/blog/%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">传送门</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><del>模板题，没有思路</del></p>
<p>一个CDQ加上一个树状数组维护就ojbk了.对于相同元素的问题，可以把序列去重，这样现在就没有相同的了，给现在的每个元素一个权值vv等于出现的次数。</p>
<p><strong>注意</strong>开始结构体排序的时候，要排对呀！（关键字不能只有第一维）。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;
import java.util.Comparator;

public class P3810三维偏序 {
public static class off implements Comparable&lt;off&gt;{
  private int a,b,c;
  private int num,ans;
  public off() { }
  public off(int a,int b,int c) {
    this.a=a;this.b=b;this.c=c;
  }
  @Override
  public int compareTo(off o) {
    if(a&gt;o.a||(a==o.a&amp;&amp;(b&gt;o.b||(b==o.b&amp;&amp;c&gt;o.c)))) {
      return 1;
    }else if(a==o.a&amp;&amp;c==o.c&amp;&amp;b==o.b) {
      return 0;
    }
    return -1;
}
}
public static class cmpb implements Comparator&lt;off&gt;{
  @Override
  public int compare(off o1, off o2) {
    if(o1.b&gt;o2.b) {
      return 1;
    }else if(o1.b&lt;o2.b) {
      return -1;
    }
    return 0;
  }
}
public static class node{
  private int tre[],kk;
  public int lwbt(int x) {return x&amp;(-x);};
  public int ask(int u) {
    int ans=0;
    for (;u&gt;0;u-=lwbt(u)) {
      ans+=tre[u];
    }
    return ans;
  }
  public void add(int i,int k) {
    for (;i&lt;=kk;i+=lwbt(i)) {
      tre[i]+=k;
    }
  }
}
static int n,k;
static off d[],a[],s[];//操作元素，去重后的操作元素，拷贝元素数组
static int em=0;//辅助
static int cnt[];//记录答案
static node t;//工具
public static void main(String[] args) throws IOException {
  Input in = new Input();StringBuilder sb = new StringBuilder();
  n=in.nextInt();k=in.nextInt();
   t=new node();t.kk=k;t.tre=new int[k+1];
  d=new off[n+2];a=new off[n+1];
  for (int i =1; i &lt;d.length-1; i++) {
    d[i]=new off(in.nextInt(),in.nextInt(),in.nextInt());
  }
  d[n+1]=new off(123335991,12331,123312);
  Arrays.sort(d,1,d.length-1);
  int v=0;
  for (int i =1; i &lt;=n; i++) {
    v++;
    if(d[i].a!=d[i+1].a||d[i].b!=d[i+1].b||d[i].c!=d[i+1].c) {
      a[++em]=d[i];a[em].num=v;v=0;
    }
  }
  s=new off[em+1];
  CDQ(1,em);
  cnt=new int[n+1];
  for (int i =1;i&lt;=em; i++) {
    cnt[a[i].ans+a[i].num-1]+=a[i].num;
  }
  for (int i =0; i &lt;n; i++) {
    sb.append(cnt[i]+&quot;\n&quot;);
  }
  System.out.println(sb);
}
public static void CDQ(int L,int R) {
  if(L==R)return;
  int mid=(L+R)&gt;&gt;1;
  CDQ(L,mid);CDQ(mid+1,R);
  int q=mid+1,p=L;int v=0;
  while(p&lt;=mid&amp;&amp;q&lt;=R) {
    if(a[p].b&lt;=a[q].b) {
      s[++v]=a[p];
      t.add(a[p].c,a[p].num);p++;
    }else {
      s[++v]=a[q];
      s[v].ans+=t.ask(a[q].c);q++;
    }
  }
  while(p&lt;=mid) {//顺序
    t.add(a[p].c,a[p].num);
    s[++v]=a[p];p++;
  }
  while(q&lt;=R) {
    s[++v]=a[q];
    s[v].ans+=t.ask(a[q].c);q++;
  }
  for (int i =L;i&lt;=mid; i++) {
    t.add(a[i].c,-a[i].num);
  }
for (int i =L, j=1; i &lt;=R; i++,j++) {
  a[i]=s[j];
}
}
public static class Input {
  StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
  public int nextInt() throws IOException {
    in.nextToken();
    return (int)in.nval;
  }
  public long nextLong() throws IOException {
    in.nextToken();
    return (long)in.nval;
  }
}
}</code></pre>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ</tag>
      </tags>
  </entry>
  <entry>
    <title>贪婪大陆</title>
    <url>/2019/12/09/blog/%E8%B4%AA%E5%A9%AA%E5%A4%A7%E9%99%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="https://www.luogu.com.cn/problem/P2184" target="_blank" rel="noopener">传送门</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;从字面上看就是每个查询区间的l与r，与多少<code>个</code>之前的覆盖区间（地雷）有交集。<br>把它换算一下理解就是，之前代表的是按时间顺序，假设查询区间左右端点是Lj和Rj，覆盖区间左右端点是Li和Ri,那么有交集的覆盖区间满足Li&lt;=Rj且Ri&gt;=L且i&lt;j。</p>
<p>&emsp;&emsp;很显然，这是一个三维偏序问题。元素储存操作类型（tye），左右端点（b，z）和第几个操作位数(a).<br>本题细节较多。<strong>注意</strong>清空（1）树状数组的操作位置的摆放（dbug我半天）。（2）数组数组的空间要确定，如果开小了，就莫名答案变负数了QAQ</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class P2184贪婪大陆 {
    public static class off{
        private int a,b,z,tye;
        public off() { }
        public off(int tye,int a,int b,int z) {
            this.a=a;this.b=b;this.tye=tye;
            this.z=z;
        }
    }
    public static class node{
        private int tre[],kk;
        public int lwbt(int x) {return x&amp;(-x);};
        public int ask(int u) {
            int ans=0;
            for (;u&gt;0;u-=lwbt(u)) {
                ans+=tre[u];
            }
            return ans;
        }
        public void add(int i,int k) {
            for (;i&lt;=kk;i+=lwbt(i)) {
                tre[i]+=k;
            }
        }
        public int query(int l,int r) {
            l--;
            int sum=0;
            while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
            while(l&gt;r) {sum-=tre[l];l-=lwbt(l);}
            return sum;
        }
    }
    static int n,m;//大小和操作数量
    static off d[],s[];//操作元素数组和拷贝数组
    static node t;//树状数组工具
    static boolean vis[];//判断是否是查询
    static int ans[];//储存答案
    public static void main(String[] args) throws IOException {
        Input in = new Input();StringBuilder sb = new StringBuilder();
        n=in.nextInt();m=in.nextInt();
        d=new off[n+1];t=new node();
        t.kk=n;t.tre=new int[n+1];s=new off[n+1];
        vis=new boolean[n+1];ans=new int[n+1];
        int x,y,z;
        for (int i =1; i &lt;=m; i++) {
            x=in.nextInt();y=in.nextInt();
            z=in.nextInt();if(x==2) {
                d[i]=new off(x,i,z,y);
                vis[i]=true;
            }else {
            d[i]=new off(x,i,y,z);
            }
        }
        CDQ(1,m);
        for (int i =1; i &lt;=m; i++) {
            if(vis[i]) {
                sb.append(ans[i]+&quot;\n&quot;);
            }
        }
        System.out.println(sb);
    }
    public static void CDQ(int L,int R) {
        if(L==R)return;
        int mid=(L+R)&gt;&gt;1;
        CDQ(L,mid);CDQ(mid+1,R);
        int p=L,q=mid+1,v=0;
        while(p&lt;=mid&amp;&amp;q&lt;=R) {
            if(d[p].b&lt;=d[q].b) {
                if(d[p].tye==1)t.add(d[p].z,1);
                s[++v]=d[p++];
            }else{
                if(d[q].tye==2) ans[d[q].a]+=t.query(d[q].z,n);
                   s[++v]=d[q++];
            }
        }
        while(q&lt;=R) {//注意顺序
            if(d[q].tye==2) ans[d[q].a]+=t.query(d[q].z,n);
            s[++v]=d[q++];
        }
        for (int i =L; i&lt;p; i++) {//上限到p就行了,清空在前,防止把后面的也算上了。
            if(d[i].tye==1)t.add(d[i].z,-1);
        }
        while(p&lt;=mid)s[++v]=d[p++];
        for (int i =L, j=1; i &lt;=R; i++,j++) {
            d[i]=s[j];
        }
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分</title>
    <url>/2019/12/09/blog/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>基于值域的整体二分。类似于一些决策单调性的分治，可以解决诸多区间第 kk 小或区间第 kk 大的问题。</p>
</blockquote>
<p>&nbsp;&nbsp;&emsp;&nbsp;把复杂的问题拆分成许多可以简单求的解子问题。但是这两种算法必须离线处理，不能解决一些强制在线的题目。不过如果题目允许离线的话，这两种算法能把在线解法吊起来打（如树套树）。</p>
<p>时间复杂度：O（(N+M)log^2 N） &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href="https://www.luogu.com.cn/blog/Owencodeisking/post-xue-xi-bi-ji-cdq-fen-zhi-hu-zheng-ti-er-fen" target="_blank" rel="noopener">参考资料</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><pre><code>import java.util.Arrays;
import java.util.Scanner;

public class Main{

public static class off{//每个原子化操作元素
    private int op,x,y,z;
    public off(){ }
    public off(int op,int x,int y,int z){
        this.op=op;this.x=x;
        this.y=y;this.z=z;
    }
}
public static class node{//树状数组工具
    private int tre[],kk;
    public int lwbt(int x) {return x&amp;(-x);};
    public int ask(int u) {//求和
        int ans=0;
        for (;u&gt;0;u-=lwbt(u)) {
            ans+=tre[u];
        }
        return ans;
    }
    public void add(int i,int k) {//单点修改
        for (;i&lt;=kk;i+=lwbt(i)) {
            tre[i]+=k;
        }
    }
    public int query(int l,int r) {//区间求和
        l--;
        int sum=0;
        while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
        while(l&gt;r) {sum-=tre[l];l-=lwbt(l);}
        return sum;
    }
}
static off d[],sl[],sr[];
static node T;
static int n,m;
static int t=0;
static int ans[];
public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);
    n=sc.nextInt();m=sc.nextInt();
    d=new off[n+2*m+1];int a[]=new int[n+1];
    int op,x,y,z;T=new node();ans=new int[n+1];
    T.kk=n;T.tre=new int[n+1];
    for (int i =1;i&lt;=n; i++) {
    a[i]=sc.nextInt();
    d[++t]=new off(0,i,a[i],1);//赋值
    }
    for (int i =1; i&lt;=m; i++) {
        op=sc.nextInt();
        x=sc.nextInt();y=sc.nextInt();
        if(op==1){//查询
            d[++t]=new off(i,x,y,sc.nextInt());
        }else{//修改
            d[++t]=new off(0,i,a[x],-1);a[x]=y;
            d[++t]=new off(0,i,a[x],1);
        }
    }
    sl=new off[t+1];sr=new off[t+1];//备份数组
    solve(Integer.MIN_VALUE,Integer.MAX_VALUE,1,t);
    for (int i =1;i&lt;=m; i++) {
        if(ans[i]==0)continue;
        System.out.println(ans[i]);
    }
}
public static void solve(int L,int R,int st,int ed){//值域二分
    if(st&gt;ed)return;//操作序列为空
    if(L==R){//值域达到边界
        for (int i =st;i&lt;=ed; i++) {
            if(d[i].op&gt;0)ans[d[i].op]=L;
        }
        return;
    }
    int mid=(L+R)&gt;&gt;1;
    int l=0,r=0;
    for (int i =st;i&lt;=ed; i++) {
        if(d[i].op==0){//赋值操作
            if(d[i].y&lt;=mid){
                T.add(d[i].x,d[i].z);sl[++l]=d[i];
            }else{
             sr[++r]=d[i];
            }
        }else{//查询操作
            int cnt=T.query(d[i].x,d[i].y);
            if(cnt&gt;=d[i].z){
                sl[++l]=d[i];
            }else{
                d[i].z-=cnt;sr[++r]=d[i];
            }
        }
    }
    for (int i=ed; i&gt;=st;i--) {//清空树状数组
        if(d[i].op==0&amp;&amp;d[i].y&lt;=mid)T.add(d[i].x,-1*d[i].z);
    }
    for (int i =1; i&lt;=l; i++) {//拷贝
        d[st+i-1]=sl[i];
    }
    for (int i =1;i&lt;=r; i++) {
        d[st+i-1+l]=sr[i];
    }
    solve(L,mid,st,st+l-1);
    solve(mid+1,R,st+l,ed);
}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>cdq与整体二分</title>
    <url>/2019/12/07/blog/%E6%B5%85%E8%B0%88cdq%E4%B8%8E%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h1><blockquote>
<p>用于解决离线或不强制在线问题中简化一层树结构的实用性分治算法</p>
</blockquote>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>主要思想还是分治的思想，即递归处理小范围信息，之后将处理的信息合并上传。一般来说，都是先处理左区间，之后用左区间更新右区间，顺便更新答案，然后处理右区间，之后再将两个区间的信息合并。<br>这一类分治有一个重要的思想——用一个子问题来计算对另一个子问题的贡献。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>(1)在分治之前先按照某一关键字排序，之后在分治过程中，将信息按照时间分成前后两部分，这样避免了多次排序。</p>
<p>(2)在分治过程中，利用归并排序的方式将两个有序序列合并，将O(nlog)的排序变为O(n)的归并。</p>
<p>(3)在分治过程中，利用树状数组解决问题，除非必须用到别的东西。</p>
<p>(4)在分治过程中，利用有序的性质可以发现，逆序也是有序的，并且满足一些正好与正序相反，这样可以避免重复排序。</p>
<p>(5)在分治之前尽可能的简化不必要的信息，这样能减少整个代码的常数。</p>
<p>(6)另外，在更新右区间或者合并的时候，尽量选择常数与时间复杂度较小的算法，比如说能用单调队列就不要用斜率优化，能用斜率优化就不要用决策单调性。</p>
<h3 id="CDQ套CDQ"><a href="#CDQ套CDQ" class="headerlink" title="CDQ套CDQ"></a>CDQ套CDQ</h3><p><strong><a href="https://blog.csdn.net/weixin_33890499/article/details/94674020" target="_blank" rel="noopener">以下为借鉴内容</a></strong></p>
<h4 id="四维偏序问题"><a href="#四维偏序问题" class="headerlink" title="四维偏序问题"></a>四维偏序问题</h4><p><strong>给定N(N&lt;=20000)个有序四元组(a,b,c,d)，求对于每一个四元组(a,b,c,d)，有多少个四元组(a2,b2,c2,d2)满足a2&lt;a &amp;&amp; b2&lt;b &amp;&amp; c2&lt;c &amp;&amp; d2&lt;d。</strong></p>
<p>这个问题很容易用树套树解决，但是树套树巨大的常数和空间消耗往往是性能的瓶颈。记得我们之前说过，CDQ分<br>治能代替复杂的数据结构，并将问题“降维”。这里，我们就用双重嵌套的CDQ分治，把这个问题继续降维，避免使用树套树。</p>
<p>回忆二维偏序问题，我们对第一维分治之后，所有的二元组被我们划分为了左右两部分，左边和右边各自的内部问题已经通过递归解决，剩下要考虑的就是左边的修改对右边的查询的影响。我们不妨把分治后的二元组重新标记一下，左边的为(L,b)，右边的为(R,b)。这时候，(a1,b1)对(a2,b2)有影响，当且仅当a1 == L &amp;&amp; a2 == R &amp;&amp; b1 &lt; b2。然后我们按照b的顺序合并，解决了这一问题。</p>
<p>对于三维偏序问题也是一样的，对第一维分治并且重新标记之后，只有(L,b1,c1)可能对(R,b2,c2)有影响。我们用“按顺序归并”保证b元素的顺序，用树状数组保证c元素的顺序。</p>
<p>对于四维偏序问题，我们也按照这样的思路进行下去。对第一维分治，并把所有元素重新标记为(L,b,c,d)和(R,b,c,d)，然后按照b的顺序合并。注意，我们在这里只是做<strong>合并</strong>，并不用任何数据结构对c和d加以维护。</p>
<p>合并完之后，我们得到了一个按照b值升序排列的序列，现在，我们把这个序列复制一份，用CDQ分治统计刚刚我们没有统计的信息——<strong>左边的修改对右边的查询的影响。</strong></p>
<p>这时候这个序列仅仅是b值有序，但是a值是杂乱无章的，不过我们之前已经对a值进行了<strong>重新标记</strong>，现在a值只可能是L或者R。<br>我们对b值进行分治，递归处理左右两边的子问题（别忘了我们现在要处理的问题是“在第一维分治之后，左边的修改对右边的查询的影响”）。然后，把所有b值也重新标号为L和R，于是我们得到了这样一个序列(L/R,L/R,c,d)。注意，现在只有(L,L,c,d)可能对(R,R,c,d)产生影响！请读者仔细考虑这个条件，这是理解多重CDQ分治的关键！</p>
<p>然后我们按照c值从小到大进行合并，这保证了统计时c值的顺序，同时用树状数组维护d值的信息，保证考虑到d值的顺序。只有一个元素为(L,L,c,d)的时候，它才可能影响到后面的查询；只有一个元素为(R,R,c,d)的时候，它才可能收到前面的修改的影响。即，我们在归并的时候，把一个d值加入树状数组，当且仅当这个四元组的a == L &amp;&amp; b == L；我们向树状数组查询d值的信息并应用到这个查询上面，当且仅当这个四元组的a == R &amp;&amp; b == R。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>对第一维进行排序。</li>
<li>对第一维重新标号，然后对第一维分治，递归解决子问题，按照第二维的顺序合并。此时只是单纯的合并，并不进行统计。</li>
<li><strong>把合并后的序列复制一份</strong>，并对第二维重新标号，在复制的那一份中进行CDQ分治。即对第二维分治，递归解决子问题，按照第三维的顺序合并。合并过程中用树状数组维护第四维的信息。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>清空树状数组的时候，最好不要用函数清空,比如<strong>Arrays.fill(t.tre,0);</strong></li>
<li>赋值函数：<strong>System.arraycopy(s,1,a,L,v);</strong></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实用的板子</title>
    <url>/2019/12/07/blog/%E5%BF%AB%E8%AF%BB%E5%BF%AB%E8%BE%93%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="快读快输板子"><a href="#快读快输板子" class="headerlink" title="快读快输板子"></a>快读快输板子</h1><pre><code>public class 快读快输 {
    public static void main(String[] args) throws IOException {
        Input in = new Input();//输入
        StringBuilder sb = new StringBuilder();//输出
        int n=in.nextInt();
        sb.append(n+&quot;\n&quot;);
        System.out.println(sb);
    }
    public static class Input {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        public int nextInt() throws IOException {
            in.nextToken();
            return (int)in.nval;
        }
        public long nextLong() throws IOException {
            in.nextToken();
            return (long)in.nval;
        }
 }
}</code></pre><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><pre><code>while(in.nextToken() != StreamTokenizer.TT_EOF)
public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in),32768));
public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
public static double nextDouble() throws IOException{ in.nextToken(); return in.nval; }
public static float nextFloat() throws IOException{ in.nextToken(); return (float)in.nval; }
public static int nextInt() throws IOException{ in.nextToken(); return (int)in.nval; }
public static String next() throws IOException{ in.nextToken(); return in.sval;}</code></pre><h2 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h2><pre><code>public class P1029 {
    public static void main(String[] args) throws IOException {
        // 这句是io流包装，记住就好
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        //StreamTokenizer.TT_EOF这个是个参数，就是EOF
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            int n = (int) in.nval;
            int appears[] = new int[32768];// 记录出现次数
            int max = 0;
            for (int i = 0; i &lt; n; i++) {
                in.nextToken();//指向下一个
                int num = (int) in.nval;//scanner.nextInt();
                appears[num]++;
                if (appears[num] &gt;= (n + 1) / 2) {
                    max = num;
                }
            }
            out.println(max);
            out.flush();//刷新，不然max会留在缓冲区
        }
    }
}</code></pre><h1 id="树状数组简单工具板子"><a href="#树状数组简单工具板子" class="headerlink" title="树状数组简单工具板子"></a>树状数组简单工具板子</h1><pre><code>public static class node{
        private int tre[],kk;
        public int lwbt(int x) {return x&amp;(-x);};
        public int ask(int u) {
            int ans=0;
            for (;u&gt;0;u-=lwbt(u)) {
                ans+=tre[u];
            }
            return ans;
        }
        public void add(int i,int k) {
            for (;i&lt;=kk;i+=lwbt(i)) {
                tre[i]+=k;
            }
        }
    public int query(int l,int r) {
            l--;
            int sum=0;
            while(r&gt;l) {sum+=tre[r];r-=lwbt(r);}
            while(l&gt;r) {sum+=tre[l];l-=lwbt(l);}
            return sum;
        }
    }</code></pre><h1 id="LCA简单板子"><a href="#LCA简单板子" class="headerlink" title="LCA简单板子"></a>LCA简单板子</h1><blockquote>
<p>以1为根</p>
</blockquote>
<h2 id="dfs版"><a href="#dfs版" class="headerlink" title="dfs版"></a>dfs版</h2><pre><code>static int mo[][],deep[]; //LCA
mo=new int[n+2][21];fa=new int[n+2];deep=new int[n+2];
//LCA AND 预处理
    public static int LCA(int x,int y) {//公共祖先
        if(deep[x]&lt;deep[y]) {int c=x;x=y;y=c;}
        for (int i =19;i&gt;=0;i--) if(deep[mo[x][i]]&gt;=deep[y])x=mo[x][i];
        for (int i =19;i&gt;=0;i--) if(mo[x][i]!=mo[y][i]) {x=mo[x][i];y=mo[y][i];}
        return x==y?x:mo[x][0];
    }
    public static void dfs(int u,int fat) {//搜索
        mo[u][0]=fat;
        deep[u]=deep[fat]+1;
        for (int i =1; i&lt;=19; i++) {
            mo[u][i]=mo[mo[u][i-1]][i-1];
        }
        for (int i =head[u]; i!=-1;i=a[i].next) {
            int v=a[i].to;if(v==fat)continue;
            dfs(v,u);
        }
    }</code></pre><h2 id="BFS版"><a href="#BFS版" class="headerlink" title="BFS版"></a>BFS版</h2><pre><code>static int mo[][],deep[]; //LCA
mo=new int[n+2][21];fa=new int[n+2];deep=new int[n+2];
public static void bfs() {
  Queue&lt;Integer&gt; d=new LinkedList&lt;Integer&gt;();
  dep[1]=1;d.add(1);int u,v,val;
  while(!d.isEmpty()) {
    u=d.poll();
    for (int i =head[u]; i!=-1;i=a[i].next) {
      v=a[i].to;if(dep[v]&gt;0)continue;val=a[i].val;
      dep[v]=dep[u]+1;d.add(v);mo[v][0]=u;dst[v][0]=val;
      for (int j =1; j&lt;=19; j++) {
      mo[v][j]=mo[mo[v][j-1]][j-1];
      dst[v][j]=dst[v][j-1]+dst[mo[v][j-1]][j-1];
    }
    }
  }
}</code></pre><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><pre><code>import java.util.Scanner;

public class Main {
    static long c = 1000000007;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for (int i = 0; i &lt; t; i++) {
            long a = 2;
            long b = sc.nextLong();
            long value = divide((long) 2, b);
            System.out.println(value % c);
        }
    }

    private static long divide(long a, long b) {
        if (b == 0)
            return 1;
        else if (b % 2 == 0) {
            return divide((a % c) * (a % c), b / 2) % c;
        } else
            return a % c * divide((a % c) * (a % c), (b - 1) / 2) % c;
    }
}</code></pre><h1 id="字符串字典序排序"><a href="#字符串字典序排序" class="headerlink" title="字符串字典序排序"></a>字符串字典序排序</h1><pre><code>char[] chars1=a.toCharArray();
     char[] chars2=b.toCharArray();
     int i=0;
     while(i&lt;chars1.length &amp;&amp; i&lt;chars2.length){
         if(chars1[i]&gt;chars2[i]){
             return false;
         }else if(chars1[i]&lt;chars2[i]){
             return true;
         }else{
             i++;
         }
     }
     if(i==chars1.length){  //o1到头
         return true;
     }
     if(i== chars2.length){ //o2到头
         return false;
     }
     return true;</code></pre><h1 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a><a href="https://blog.csdn.net/tinydolphin/article/details/75208771" target="_blank" rel="noopener">欧拉筛</a></h1><pre><code>private static void Euler(int num) {
       int count = 0;
       for (int indexI = 2; indexI &lt;= num; indexI++) {
           if (!check[indexI]) {
               primeList[count++] = indexI;
           }
           // 每一个数都去乘以当前素数表里面已有的数，如果 indexI 是合数，且 indexI % primeList[indexJ] == 0，那么它只能乘以第一个素数 2
           // 如：2×2、3×(2、3)、4×(2)、5×(2、3、5)、6×(2)、7×(2、3、5、7)、8×(2)、9×(2、3)、10×(2)
           for (int indexJ = 0; indexJ &lt; count; indexJ++) {
               // 过大的时候跳出
               if (indexI * primeList[indexJ] &gt; num) {
                   break;
               }
               check[indexI * primeList[indexJ]] = true;
               // 如果 indexI 是一个合数，而且 indexI % primeList[indexJ] == 0
               // 保证了每个合数只会被它的最小素因子筛掉
               if (indexI % primeList[indexJ] == 0) {
                   break;
               }
           }
       }
   }</code></pre><h1 id="预处理组合数"><a href="#预处理组合数" class="headerlink" title="预处理组合数"></a>预处理组合数</h1><blockquote>
<p>显然具有相同1/0个数的状态，出现次数一样</p>
</blockquote>
<pre><code>for (int i = 0; i &lt;21; i++) {
  c[i][0]=1;
}
for (int i =1; i &lt;=20; i++) {
  for (int j =1; j &lt;=20; j++) {
    c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
  }
}</code></pre><h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a><a href="https://www.cnblogs.com/zjp-shadow/p/7773566.html" target="_blank" rel="noopener">乘法逆元</a></h1>]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>板子</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP学习笔记</title>
    <url>/2019/11/27/blog/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h1><h3 id="游览器：web-browser-资源：resourse-客户端：client"><a href="#游览器：web-browser-资源：resourse-客户端：client" class="headerlink" title="游览器：web browser  资源：resourse  客户端：client"></a>游览器：web browser  资源：resourse  客户端：client</h3><h3 id="HTTP：HyperText-Transfer-Protocol-超文本传输协议。"><a href="#HTTP：HyperText-Transfer-Protocol-超文本传输协议。" class="headerlink" title="HTTP：HyperText Transfer Protocol , 超文本传输协议。"></a>HTTP：HyperText Transfer Protocol , 超文本传输协议。</h3><h3 id="协议-指规则的约定。（Protocol）"><a href="#协议-指规则的约定。（Protocol）" class="headerlink" title="协议: 指规则的约定。（Protocol）"></a>协议: 指规则的约定。（Protocol）</h3><h3 id="FTP-File-Transfer-Protocol-文本传输协议。"><a href="#FTP-File-Transfer-Protocol-文本传输协议。" class="headerlink" title="FTP : File Transfer Protocol, 文本传输协议。"></a>FTP : File Transfer Protocol, 文本传输协议。</h3><h3 id="DNS：Domain-Name-System-域名系统。"><a href="#DNS：Domain-Name-System-域名系统。" class="headerlink" title="DNS：Domain Name System.域名系统。"></a>DNS：Domain Name System.域名系统。</h3><h3 id="TCP-Transmission-Control-Protocol-传输协议控制。"><a href="#TCP-Transmission-Control-Protocol-传输协议控制。" class="headerlink" title="TCP: Transmission Control Protocol.传输协议控制。"></a>TCP: Transmission Control Protocol.传输协议控制。</h3><h3 id="UDP：User-Data-Protocol-用户数据报协议。"><a href="#UDP：User-Data-Protocol-用户数据报协议。" class="headerlink" title="UDP：User Data Protocol.用户数据报协议。"></a>UDP：User Data Protocol.用户数据报协议。</h3><h3 id="NIC：Network-Interface-Card-网络适配器。即网卡。"><a href="#NIC：Network-Interface-Card-网络适配器。即网卡。" class="headerlink" title="NIC：Network Interface Card.网络适配器。即网卡。"></a>NIC：Network Interface Card.网络适配器。即网卡。</h3><h3 id="MAC地址：网卡所属的固定的位置。-区域网：LAN"><a href="#MAC地址：网卡所属的固定的位置。-区域网：LAN" class="headerlink" title="MAC地址：网卡所属的固定的位置。  区域网：LAN"></a>MAC地址：网卡所属的固定的位置。  区域网：LAN</h3><h3 id="ARP：用于解析ip查出对应的MAC地址的协议"><a href="#ARP：用于解析ip查出对应的MAC地址的协议" class="headerlink" title="ARP：用于解析ip查出对应的MAC地址的协议"></a>ARP：用于解析ip查出对应的MAC地址的协议</h3><h3 id="URL-统一资源标识符。URI是URL的子集。"><a href="#URL-统一资源标识符。URI是URL的子集。" class="headerlink" title="URL: 统一资源标识符。URI是URL的子集。"></a>URL: 统一资源标识符。URI是URL的子集。</h3><h3 id="URI：统一资源定位符。"><a href="#URI：统一资源定位符。" class="headerlink" title="URI：统一资源定位符。"></a>URI：统一资源定位符。</h3>]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让大脑专注</title>
    <url>/2019/11/21/life/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%A7%E8%84%91%E4%B8%93%E6%B3%A8/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>我们的大脑喜欢碎片式的信息，而科技的进步，手机应用的不断增加，短内容的丰富，正好满足了我们大脑的需求，不断的挤压我们的时间，持续分散我们的注意力。我们大脑每天面临着过度的刺激，当我们想要分散注意力时，大脑也会通过多巴胺第一时间奖励我们，使我们在不同的受注意对象之间来回切换，我们该怎样使大脑更加平静？</p>
</blockquote>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.bilibili.com/video/av75883891" target="_blank" rel="noopener">如何让你的大脑专注？</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>给自己的大脑更多空间，就是说给自己放空的机会，这样可以有更多更新颖的想法。比如洗澡、泡澡、做按摩就是放松大脑的好机会。</li>
<li>我们都以为注意力分散是集中注意的敌人、原因，其实它只是大脑超载的一种表现。</li>
<li>尝试着限制屏幕使用时间，持续一周多就会有明显的改变，如注意广度的增加等等好处。</li>
<li>我认为精神集中的<strong>前提</strong>是大脑保持清醒或者说是放松状态，人们所常说的发呆，打发时间其实就是一种让大脑放松的形式。很多伟大的想法都是在不经意间像出来的，大脑的发散性能帮助我get good idea。</li>
<li>放松的时候，大脑的思维模式是没有局限性的，可以增加思维的广度，缓解压力。可以选择一种放松，每天给自己的大脑放松放松（<del>打游戏</del>）。</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>人像摄影</title>
    <url>/2019/11/19/blog/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/</url>
    <content><![CDATA[<h1 id="布光"><a href="#布光" class="headerlink" title="布光"></a>布光</h1><h2 id="伦勃朗光"><a href="#伦勃朗光" class="headerlink" title="伦勃朗光"></a>伦勃朗光</h2><blockquote>
<p>给人脸形成很好的高光和影调</p>
</blockquote>
<p>位置：人物前左右四十五度斜上方，打在人物脸部<br>描述：对人物脸部有点要求 ，会在人物脸部背光的一侧形成三角形的高光区。</p>
<h2 id="环形光"><a href="#环形光" class="headerlink" title="环形光"></a>环形光</h2><blockquote>
</blockquote>
<p>位置：20到30度，灯光稍微高于人物眼睛，从上往下打。</p>
<h2 id="正面偏顶光"><a href="#正面偏顶光" class="headerlink" title="正面偏顶光"></a>正面偏顶光</h2><blockquote>
<p>会在下巴，鼻子下面形成很强烈的阴影，由此让模特侧着，抬起下巴。</p>
</blockquote>
<p>位置：顾名思义</p>
<h2 id="90度光"><a href="#90度光" class="headerlink" title="90度光"></a>90度光</h2><blockquote>
<p>富有戏剧效果，不建议女性拍摄角度，男性显得神秘感些。</p>
</blockquote>
<p>位置：90度</p>
<h2 id="蝴蝶光"><a href="#蝴蝶光" class="headerlink" title="蝴蝶光"></a>蝴蝶光</h2><blockquote>
<p>人物鼻子下面会有一个类似蝴蝶一样的阴影</p>
</blockquote>
<p>位置：从人物正上方，45度打下来。<br>描述：通常人物下面会有一个反光板，填充人物面部的阴影，增加一个很好看的眼神光（天气很好没强光的时候一样）</p>
<h2 id="背光"><a href="#背光" class="headerlink" title="背光"></a>背光</h2><blockquote>
<p>有剪影效果，摆姿纯侧面，拍轮廓。</p>
</blockquote>
<p>位置：后面<br>描述：用手摸额头或者脖子加以修饰。</p>
<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><p> 建议模特向灯光偏一点，起显瘦效果。</p>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol>
<li><strong>熟悉模特的风格</strong>。和模特沟通好，拍些手部等特写。</li>
<li><strong>合适焦段</strong>。可以利用场景中的线条引导，形成很好的构图。</li>
<li><strong>融入场景</strong>。不用一直对着镜头，拍自然的照，使用高速连拍，一顿快拍，定格自然的照片（如转圈圈）。</li>
<li>使用<strong>小道具</strong>。增加前景虚化的效果让画面唯美一些，比如说三棱镜，一片简简单单的叶子。</li>
<li><strong>正方体构图法</strong>。把模特想象在一个正方体里面，在八个角去拍摄。</li>
<li><strong>前景虚化</strong>。比如说把相机放在草地上拍摄小姐姐，用树枝当前景等。</li>
<li><strong>裁切</strong>。拍摄边界的地方注意。</li>
<li><strong>模特pose</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>景物拍攝</title>
    <url>/2019/11/19/blog/%E6%99%AF%E7%89%A9%E6%8B%8D%E6%94%9D/</url>
    <content><![CDATA[<h1 id="天空"><a href="#天空" class="headerlink" title="天空"></a>天空</h1><blockquote>
<p>将天空为背景，加入一些生活中常见的景物，让画面简洁又美观，反向衬托。</p>
</blockquote>
<p>  比如篮球架，屋顶，云朵等</p>
<h1 id="亦真亦假虚实结合"><a href="#亦真亦假虚实结合" class="headerlink" title="亦真亦假虚实结合"></a>亦真亦假虚实结合</h1><blockquote>
<p>利用小道具，如手办等，场景拍摄，显得真实感</p>
</blockquote>
<h1 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h1><blockquote>
<p>注重色彩的表现张力</p>
</blockquote>
<p>可以选择在有水洼的地方拍摄，通过水洼的反射光，形成色彩丰富的前景。如电影拍摄街道的时候，地不会是干的。<br>拍摄街道车辆灯尾驶出的效果。可以三脚架支持，快门调制2s左右。<br>充分运用花里胡哨的灯光特效，抓拍，定格，一闪而过，精彩的场景。</p>
]]></content>
      <categories>
        <category>攝影</category>
      </categories>
      <tags>
        <tag>攝影</tag>
      </tags>
  </entry>
  <entry>
    <title>图片管理2</title>
    <url>/2019/11/18/blog/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%862/</url>
    <content><![CDATA[<h1 id="awd"><a href="#awd" class="headerlink" title="awd"></a>awd</h1><p><img src="/.com//123.jpg" alt="asd"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的日常操作</title>
    <url>/2019/11/09/engineer/HexoCode/</url>
    <content><![CDATA[<h1 id="博文的写作"><a href="#博文的写作" class="headerlink" title="博文的写作"></a>博文的写作</h1><blockquote>
<p>hexo new [Layout] <code>&lt;</code>title<code>&gt;</code></p>
</blockquote>
<p> <a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">参考文档</a> <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">参考文档2</a><br>  默认的布局(Layout)是post，可以通过改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局。</p>
<h2 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h2><ul>
<li>默认文章布局有<code>post</code>,<code>page</code>和<code>draft</code>。</li>
<li>在创建不同类型的文件的时候会被保存在不同的路径上；</li>
<li>而自定义的布局会和post相同，被保持在<code>source/_posts</code>文件夹中。</li>
</ul>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p>
<pre><code>$ hexo publish [layout] &lt;title&gt;</code></pre><p>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/.com//123.jpg" alt="没有描述"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h1 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h1><pre><code>hexo -c 清除缓存
hexo -g 生成静态文件
hexo -d 布置网站
hexo -s 调试</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>当想强制定义自己创建文件的路径时可以在命令行中加上<code>--path</code>字段<br>比如：<code>$ hexo new --path engineer/Code &quot;Hexo&quot;</code></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom编写MarkDown</title>
    <url>/2019/11/09/engineer/AtomMD/</url>
    <content><![CDATA[<h1 id="Atom简介"><a href="#Atom简介" class="headerlink" title="Atom简介"></a>Atom简介</h1><ul>
<li>Atom是GitHub开发的一款跨平台（Windows、Mac、Linux）文本编辑器，2015年Atom正式发布1.0版，开源，至于收费目前还没有听说，传言成熟后商用会收费；</li>
<li>Atom是基于web技术构建的，界面看起来比其他的IDE更美观、更现代化。</li>
</ul>
<h1 id="Atom常用快捷键"><a href="#Atom常用快捷键" class="headerlink" title="Atom常用快捷键"></a>Atom常用快捷键</h1><pre><code>Crtl+Shift+M    打开默认Markdown实时预览
Crtl+Shift+p    打开搜索面板，可以查询安装包、Themes等各种选项
Crtl+Shift+f    全局查找和替换(默认不区分大小写，Crtl+Shift+c可以切换是否区分)
Crtl+f          文件内查找和替换(默认不区分大小写，Crtl+Shift+c可以切换是否区分)
Crtl+\          显示或隐藏目录树
Crtl+Alt+b      格式化代码（需要安装atom-beautify）</code></pre>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>xml注意事项</title>
    <url>/2019/11/09/engineer/xml/</url>
    <content><![CDATA[<p>##XML格式</p>
<blockquote>
<p>最首先（绝对是第一行）的是文档申明<br>申明格式<?xml version="1.0" encoding="UTF-8" ?></p>
</blockquote>
<ol>
<li>文档声明之后的第一个标签（根标签）之后,所有的标签都要在这个之中，一个xml文件只有<strong>一个根标签</strong>，起到规范性，单元性。</li>
</ol>
<p>##CDATA<br>定义：非法字符集<br>其替代品不会被xml的解析器所解析<br>###内容<br>      &lt;         &lt;<br>      &gt;         &gt;<br>      &apos;       ‘<br>      &amp;        &amp;<br>      &amp;quot        “</p>
<p><strong>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束：</strong></p>
<p>##解析方式<br>###DOM：<br>把整个xml全部读到内存当中，形成树状结构。把整个文档称之为document对象。<br>缺点：如果文件很大，会内存溢出。<br>优点：如果文档比较小就解析快。可以进行文档的增删操作。<br>###SAX<br>基于事件驱动。读一行，解析一行。<br>优点：不会造成内存溢出。<br>缺点：不可以进行文档的增删操作。只能进行查询。</p>
<p>##如何实现<br>手段：dom4j<br>位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml 里面的jar<br>使用跟jdbc一样build path。<br>###流程</p>
<ol>
<li>创建sax读取对象<br>SAXReader reader=new SAXReader();</li>
<li>指定解析的xml源<br>Document d=reader.read(new File(“src/Xml/Damo01.xml”));<br>格式；reader.read(new File(工程下的路径地址的字符串));</li>
<li>得到根元素<br>Element root= d.<strong>getRootElement()</strong>;</li>
<li>获取元素<blockquote>
<p>element.element(“stu”) : 返回该元素下的第一个stu元素<br>element.elements(); 返回该元素下的所有子元素。</p>
</blockquote>
</li>
</ol>
<p>List<Element> elements = root.elements();<br>遍历所有的stu元素<br>for (Element element : elements) {<br>获取stu元素下面的name元素<br>String name = element.element   (“name”).getText();<br>String age = element.element  (“age”).getText();<br>String address = element.element   (“address”).getText();<br>System.out.println(“name=”+name+”==age+”+age+”==address=”+address);<br>}</Element></p>
<p>###Dom4j 的 Xpath使用</p>
<blockquote>
<p> dom4j里面支持Xpath的写法。 xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。<br> 说明文档位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml</p>
</blockquote>
<ol>
<li><p>添加jar包依赖<br>jaxen-1.1-beta-6.jar<br>位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml\dom4j-1.6.1\lib</p>
</li>
<li><p>在查找指定节点的时候，根据XPath语法规则来查找</p>
</li>
<li><p>后续的代码与以前的解析代码一样。</p>
</li>
</ol>
<pre><code>//要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。
Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;);
System.out.println(nameElement.getText());


System.out.println(&quot;----------------&quot;);

//获取文档里面的所有name元素
List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;);
for (Element element : list) {
    System.out.println(element.getText());
}</code></pre><p>注意：“//AA”双斜杠AA是所有AA标签下的，“/”代表路径</p>
<p>##xml文档约束（看笔记）</p>
<blockquote>
<p>DTD<br>Schema</p>
</blockquote>
<p>##服务器<br>###tomcat</p>
<ul>
<li>是个静态的，当你更新完的时候记得重启服务器</li>
</ul>
<p>###1.  拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问：</p>
<pre><code>http://localhost:8080/stu.xml</code></pre><ul>
<li><p>在webaps下面新建一个文件夹xml  , 然后拷贝文件放置到这个文件夹中</p>
<pre><code>http://localhost:8080/xml/stu.xml
http://localhost:8080 ： 其实对应的是到webapps/root
http://localhost:8080/xml/ : 对应是 webapps/xml

使用IP地址访问：

http://192.168.37.48:8080/xml/stu.xml</code></pre></li>
</ul>
<p>###2. 配置虚拟路径<br>好处：自定义路径名称</p>
<p>##小细节</p>
<ol>
<li>当你文件写的时候是gbk，然而保存的时候编码选择是ANSI（本地默认的本地编码，一般就是GBK）时就会乱码应为游览器的编码是UTF-8，这个时候要改变编码模式，比如UTF-8.</li>
<li>GBK与UTF-8。比如GBK是一次性读一个字节，而中文一般是两个字节的。所以乱码问题就是编码模式没有保持一致性。</li>
<li>但工程<strong>带有感叹号</strong>的时候，多半就是你的 Build path 中多了双重的jar文件，导致某些jar被kill了。<br>解决方式：右键工程 build path 中的configure build path，在libar的框里面把一个jar删去（remove）。</li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>图片管理</title>
    <url>/2019/10/23/blog/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><img src="/.com//123.jpg" alt="meizi"><br>真香！！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2019/10/23/blog/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><ul>
<li>使用#号进行标记标题级别<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题</code></pre></li>
</ul>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><blockquote>
<p>每行末尾空两格再回车</p>
</blockquote>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><blockquote>
<p>在一行中用三个以上的星号、减号、底线来建立一个分隔线。</p>
</blockquote>
<hr>
<p>————如这样————</p>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><blockquote>
<p>再文字的两端加上两个波浪线</p>
</blockquote>
<p><del>阿瓦达</del><br>​<code>~~啊瓦达~~</code></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><blockquote>
<p>可以通过HTML的​<code>&lt;u&gt;​</code>标签来实现</p>
</blockquote>
<pre><code>&lt;u&gt;带下划线的内容&lt;/u&gt;</code></pre><h2 id="首行缩进空格"><a href="#首行缩进空格" class="headerlink" title="首行缩进空格"></a>首行缩进空格</h2><p>（1） 一个空格大小的表示：<code>&amp;ensp;</code>或者<code>&amp;#8194;</code><br>（2） 两个空格大小的表示：<code>&amp;emsp;</code>或者<code>&amp;#8195;</code></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><blockquote>
<p>MarkDown 支持有序列表 和 无序列表</p>
</blockquote>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><blockquote>
<p>无序列表使用星号(*****)、加号(+)或是减号(-)作为列表标记</p>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><blockquote>
<p>有序列表使用数字并加上 . 号空格来表示</p>
</blockquote>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><blockquote>
<p>列表嵌套只需在子列表中的选项添加四个空格即可</p>
</blockquote>
<pre><code>1.parent1
    +p1-child1
    +p1-child2
2.parent2
    -p2-child1
    -p2-child2</code></pre><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><blockquote>
<p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br>区块是可以嵌套的</p>
</blockquote>
<pre><code>&gt; MarkDown

&gt;&gt; MarkDown</code></pre><p>区块于列表结合</p>
<blockquote>
<p>1.区块中使用列表<br>2.列表中使用区块</p>
</blockquote>
<pre><code>&gt; 区块中使用列表
&gt; 1. 有序
&gt; + 无序
&gt; 2. 有序
&gt; - 无序

1. 列表中使用区块
    &gt; 区块内容
    &gt;&gt; 区块内容
2. 列表中使用区块</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code>[链接名称](链接地址)
或者
&lt;链接地址&gt;

// 例：
[百度](www.baidu.com)
&lt;www.baidu.com&gt;</code></pre><h2 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h2><blockquote>
<p>链接也可以用变量来代替，文档末尾附带变量地址</p>
</blockquote>
<pre><code>百度[百度][1]
教育宝[教育宝][jyb]

[1]:www.baidu.con
[jyb]:https://www.jiaoyubao.cn/</code></pre><p><a href="www.baidu.con">百度</a></p>
<h1 id="引用本地图片"><a href="#引用本地图片" class="headerlink" title="引用本地图片"></a>引用本地图片</h1><blockquote>
<p>在hexo中把图片放在与博客同名的文件夹中，然后只用 <code>![图片描述](图片文件名)</code>就可以引用了。</p>
</blockquote>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h2 id="一小代码"><a href="#一小代码" class="headerlink" title="一小代码"></a>一小代码</h2><blockquote>
<p>可以用字符 ` 括起来。</p>
</blockquote>
<p>比如说<code>代码</code>。</p>
<pre><code>比如说`代码`。</code></pre><h2 id="一大代码"><a href="#一大代码" class="headerlink" title="一大代码"></a>一大代码</h2><blockquote>
<p>整体缩进两次就行</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2019/10/23/blog/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p><a href="https://www.luogu.org/problem/P1495" target="_blank" rel="noopener">相关题面</a></p>
<h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><pre><code>int intchina(int r)
{
int Mi,x,y,d,ans=0;M=1;
for(int i=1;i&lt;=r;i++) M*=m[i];
for(int i=1;i&lt;=r;i++){
    M[i]=M/m[i];
    exgcd(Mi,m[i],d,x,y);
    ans=(ans+Mi*x*a[i])%M;
}
return (ans+M)%M; //正解
}</code></pre><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">相关题面</a></p>
<h2 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h2><pre><code>ll exgcd(ll a,ll b,ll &amp;x1, ll &amp;y1)
{
    if(!b)
    {
        x1=1;
        y1=0;
        return a;
    }
    ans=exgcd(b,a%b,x1,y1);
    ll t=x1;  //交换逆向求解
    x1=y1;
    y1=t-a/b*y1;
    return ans;
}</code></pre><ol>
<li>xa/d-yb/d=A/d这个方程就是扩展欧几里得exgcd(a,b,x,y)（忽略y前的负号），这样可以解出x，此时的x不是最优解，还要转换，即((x*(A/d))%(b/d)+(b/d))%(b/d)【求最小解的式子，不理解先背下来】。d是模。</li>
<li>当x不是最小正数解时，写成 x = (x % b + b) % b;循环至为正；</li>
</ol>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<p>————未学待补————</p>
</blockquote>
<hr>
<h1 id="二次剩余CipollaCipolla"><a href="#二次剩余CipollaCipolla" class="headerlink" title="二次剩余CipollaCipolla"></a>二次剩余CipollaCipolla</h1><p><a href="https://www.cnblogs.com/bztMinamoto/p/10664973.html" target="_blank" rel="noopener">学习资料1</a><br><a href="https://www.luogu.org/blog/oieremtkotori/2-0v0" target="_blank" rel="noopener">学习资料2</a></p>
<blockquote>
<p>————未学待补————</p>
</blockquote>
<hr>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>欧拉函数是小于x的整数中与x互质的数的个数，一般用φ(x)表示。特殊的，φ(1)=1。</p>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>先介绍一下什么是积性函数，后面将会用到。若当m与n互质时，f(m∗n)=f(m)∗f(n)，那么f是积性函数。若对任意正整数，都有f(m<em>n)=f(m)</em>f(n)成立，则f是完全积性函数。</p>
<p>##性质</p>
<ol>
<li>对于质数p,它的欧拉函数等于p-1.</li>
<li>若p为质数，n=p的k次方，则欧拉函数等于p^k-p^(k-1).比如说n的k次方分解质数只有p，则(p^k)*(1-1/p);</li>
<li>欧拉函数是积性函数，但不是完全积性函数。若m,n互质。则φ(m∗n)=φ(m)∗φ(n).特殊的，当m=2，n为奇数时，φ(2*n)=φ(n)。</li>
<li>当n&gt;2时，φ(n)是偶数.</li>
<li>小于n的数中,与n互质的数的总和为：φ(n)*n/2(n&gt;1);</li>
<li>n的因数的欧拉函数（包括1和它自己）的欧拉函数之和等于n。</li>
<li></li>
</ol>
<pre><code>  public static long ask(long m){//查单个欧拉函数
          long ans=m;
          for (long i =2; i*i&lt;=m; i++) {
              if(m%i==0){
                  ans=ans/i*(i-1);
                  while(m%i==0)m/=i;
              }
          }
          if(m&gt;1)ans=ans/m*(m-1);
          return ans;
      }

  public static void euler(int n) {//求一堆
    phi[1]=1;//特判
    for (int i =2; i &lt;=n; i++) {
        if(!flag[i]) {//判断是不是质数
            prime[++cent]=i;
            phi[i]=i-1;
        }
        for (int j =1; j&lt;=cent&amp;&amp;prime[j]*i&lt;=n; j++) {//欧拉筛
            flag[i*prime[j]]=true;//标记非质数
            if(i%prime[j]==0) {
                phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子
                break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次
            }else {
                phi[i*prime[j]]=phi[i]*phi[prime[j]];//积性函数
            }
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>伟大尝试</title>
    <url>/2019/10/23/%E4%BC%9F%E5%A4%A7%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>开始新的篇章<br>欢迎来到我的世界</p>
</blockquote>
<h1 id="阿瓦达"><a href="#阿瓦达" class="headerlink" title="阿瓦达"></a>阿瓦达</h1><h2 id="瓦大的有读"><a href="#瓦大的有读" class="headerlink" title="瓦大的有读"></a><em>瓦大的有读</em></h2><hr>
<h2 id="沃兹"><a href="#沃兹" class="headerlink" title="沃兹"></a><u>沃兹</u></h2><ol>
<li>awdawd</li>
<li>12321</li>
</ol>
<hr>
<ul>
<li>awdaw<blockquote>
<p>adawd</p>
<blockquote>
<p>awdawdwad</p>
<blockquote>
<p>awdawd</p>
<blockquote>
<p>dawdwadaw</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>有序</li>
</ol>
<ul>
<li>无序</li>
</ul>
<ol start="2">
<li>有序</li>
</ol>
<ul>
<li>无序</li>
</ul>
</blockquote>
<ol>
<li>列表中使用区块<blockquote>
<p>区块内容</p>
<blockquote>
<p>区块内容</p>
</blockquote>
</blockquote>
</li>
<li>列表中使用区块</li>
</ol>
<p><a href="www.baidu.com">百度</a><br>| awdaw | 啊达瓦 |</p>
<p><del>ad</del></p>
]]></content>
      <categories>
        <category>废话</category>
      </categories>
      <tags>
        <tag>废话</tag>
      </tags>
  </entry>
</search>
