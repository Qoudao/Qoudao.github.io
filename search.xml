<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图片管理2</title>
    <url>/2019/11/18/blog/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%862/</url>
    <content><![CDATA[<h1 id="awd"><a href="#awd" class="headerlink" title="awd"></a>awd</h1><p><img src="/.com//123.jpg" alt="asd"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的日常操作</title>
    <url>/2019/11/09/engineer/HexoCode/</url>
    <content><![CDATA[<h1 id="博文的写作"><a href="#博文的写作" class="headerlink" title="博文的写作"></a>博文的写作</h1><blockquote>
<p>hexo new [Layout] <code>&lt;</code>title<code>&gt;</code></p>
</blockquote>
<p> <a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">参考文档</a> <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">参考文档2</a><br>  默认的布局(Layout)是post，可以通过改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局。</p>
<h2 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h2><ul>
<li>默认文章布局有<code>post</code>,<code>page</code>和<code>draft</code>。</li>
<li>在创建不同类型的文件的时候会被保存在不同的路径上；</li>
<li>而自定义的布局会和post相同，被保持在<code>source/_posts</code>文件夹中。</li>
</ul>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p>
<pre><code>$ hexo publish [layout] &lt;title&gt;</code></pre><p>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="/.com//123.jpg" alt="没有描述"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h1 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h1><pre><code>hexo -c 清除缓存
hexo -g 生成静态文件
hexo -d 布置网站
hexo -s 调试</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>当想强制定义自己创建文件的路径时可以在命令行中加上<code>--path</code>字段<br>比如：<code>$ hexo new --path engineer/Code &quot;Hexo&quot;</code></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom编写MarkDown</title>
    <url>/2019/11/09/engineer/AtomMD/</url>
    <content><![CDATA[<h1 id="Atom简介"><a href="#Atom简介" class="headerlink" title="Atom简介"></a>Atom简介</h1><ul>
<li>Atom是GitHub开发的一款跨平台（Windows、Mac、Linux）文本编辑器，2015年Atom正式发布1.0版，开源，至于收费目前还没有听说，传言成熟后商用会收费；</li>
<li>Atom是基于web技术构建的，界面看起来比其他的IDE更美观、更现代化。</li>
</ul>
<h1 id="Atom常用快捷键"><a href="#Atom常用快捷键" class="headerlink" title="Atom常用快捷键"></a>Atom常用快捷键</h1><pre><code>Crtl+Shift+M    打开默认Markdown实时预览
Crtl+Shift+p    打开搜索面板，可以查询安装包、Themes等各种选项
Crtl+Shift+f    全局查找和替换(默认不区分大小写，Crtl+Shift+c可以切换是否区分)
Crtl+f          文件内查找和替换(默认不区分大小写，Crtl+Shift+c可以切换是否区分)
Crtl+\          显示或隐藏目录树
Crtl+Alt+b      格式化代码（需要安装atom-beautify）</code></pre>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>xml注意事项</title>
    <url>/2019/11/09/engineer/xml/</url>
    <content><![CDATA[<p>##XML格式</p>
<blockquote>
<p>最首先（绝对是第一行）的是文档申明<br>申明格式<?xml version="1.0" encoding="UTF-8" ?></p>
</blockquote>
<ol>
<li>文档声明之后的第一个标签（根标签）之后,所有的标签都要在这个之中，一个xml文件只有<strong>一个根标签</strong>，起到规范性，单元性。</li>
</ol>
<p>##CDATA<br>定义：非法字符集<br>其替代品不会被xml的解析器所解析<br>###内容<br>      &lt;         &lt;<br>      &gt;         &gt;<br>      &apos;       ‘<br>      &amp;        &amp;<br>      &amp;quot        “</p>
<p><strong>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束：</strong></p>
<p>##解析方式<br>###DOM：<br>把整个xml全部读到内存当中，形成树状结构。把整个文档称之为document对象。<br>缺点：如果文件很大，会内存溢出。<br>优点：如果文档比较小就解析快。可以进行文档的增删操作。<br>###SAX<br>基于事件驱动。读一行，解析一行。<br>优点：不会造成内存溢出。<br>缺点：不可以进行文档的增删操作。只能进行查询。</p>
<p>##如何实现<br>手段：dom4j<br>位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml 里面的jar<br>使用跟jdbc一样build path。<br>###流程</p>
<ol>
<li>创建sax读取对象<br>SAXReader reader=new SAXReader();</li>
<li>指定解析的xml源<br>Document d=reader.read(new File(“src/Xml/Damo01.xml”));<br>格式；reader.read(new File(工程下的路径地址的字符串));</li>
<li>得到根元素<br>Element root= d.<strong>getRootElement()</strong>;</li>
<li>获取元素<blockquote>
<p>element.element(“stu”) : 返回该元素下的第一个stu元素<br>element.elements(); 返回该元素下的所有子元素。</p>
</blockquote>
</li>
</ol>
<p>List<Element> elements = root.elements();<br>遍历所有的stu元素<br>for (Element element : elements) {<br>获取stu元素下面的name元素<br>String name = element.element   (“name”).getText();<br>String age = element.element  (“age”).getText();<br>String address = element.element   (“address”).getText();<br>System.out.println(“name=”+name+”==age+”+age+”==address=”+address);<br>}</Element></p>
<p>###Dom4j 的 Xpath使用</p>
<blockquote>
<p> dom4j里面支持Xpath的写法。 xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。<br> 说明文档位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml</p>
</blockquote>
<ol>
<li><p>添加jar包依赖<br>jaxen-1.1-beta-6.jar<br>位置：D:\BaiduNetdiskDownload2\09.XML&amp;tomcat(共28集)\源码笔记\code&amp;资料\资料\xml\dom4j-1.6.1\lib</p>
</li>
<li><p>在查找指定节点的时候，根据XPath语法规则来查找</p>
</li>
<li><p>后续的代码与以前的解析代码一样。</p>
</li>
</ol>
<pre><code>//要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。
Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;);
System.out.println(nameElement.getText());


System.out.println(&quot;----------------&quot;);

//获取文档里面的所有name元素
List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;);
for (Element element : list) {
    System.out.println(element.getText());
}</code></pre><p>注意：“//AA”双斜杠AA是所有AA标签下的，“/”代表路径</p>
<p>##xml文档约束（看笔记）</p>
<blockquote>
<p>DTD<br>Schema</p>
</blockquote>
<p>##服务器<br>###tomcat</p>
<ul>
<li>是个静态的，当你更新完的时候记得重启服务器</li>
</ul>
<p>###1.  拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问：</p>
<pre><code>http://localhost:8080/stu.xml</code></pre><ul>
<li><p>在webaps下面新建一个文件夹xml  , 然后拷贝文件放置到这个文件夹中</p>
<pre><code>http://localhost:8080/xml/stu.xml
http://localhost:8080 ： 其实对应的是到webapps/root
http://localhost:8080/xml/ : 对应是 webapps/xml

使用IP地址访问：

http://192.168.37.48:8080/xml/stu.xml</code></pre></li>
</ul>
<p>###2. 配置虚拟路径<br>好处：自定义路径名称</p>
<p>##小细节</p>
<ol>
<li>当你文件写的时候是gbk，然而保存的时候编码选择是ANSI（本地默认的本地编码，一般就是GBK）时就会乱码应为游览器的编码是UTF-8，这个时候要改变编码模式，比如UTF-8.</li>
<li>GBK与UTF-8。比如GBK是一次性读一个字节，而中文一般是两个字节的。所以乱码问题就是编码模式没有保持一致性。</li>
<li>但工程<strong>带有感叹号</strong>的时候，多半就是你的 Build path 中多了双重的jar文件，导致某些jar被kill了。<br>解决方式：右键工程 build path 中的configure build path，在libar的框里面把一个jar删去（remove）。</li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>图片管理</title>
    <url>/2019/10/23/blog/%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><img src="/.com//123.jpg" alt="meizi"><br>真香！！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2019/10/23/blog/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><ul>
<li>使用#号进行标记标题级别<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题</code></pre></li>
</ul>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><blockquote>
<p>每行末尾空两格再回车</p>
</blockquote>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><blockquote>
<p>在一行中用三个以上的星号、减号、底线来建立一个分隔线。</p>
</blockquote>
<hr>
<p>————如这样————</p>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><blockquote>
<p>再文字的两端加上两个波浪线</p>
</blockquote>
<p><del>阿瓦达</del><br>​<code>~~啊瓦达~~</code></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><blockquote>
<p>可以通过HTML的​<code>&lt;u&gt;​</code>标签来实现</p>
</blockquote>
<pre><code>&lt;u&gt;带下划线的内容&lt;/u&gt;</code></pre><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><blockquote>
<p>MarkDown 支持有序列表 和 无序列表</p>
</blockquote>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><blockquote>
<p>无序列表使用星号(*****)、加号(+)或是减号(-)作为列表标记</p>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><blockquote>
<p>有序列表使用数字并加上 . 号空格来表示</p>
</blockquote>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><blockquote>
<p>列表嵌套只需在子列表中的选项添加四个空格即可</p>
</blockquote>
<pre><code>1.parent1
    +p1-child1
    +p1-child2
2.parent2
    -p2-child1
    -p2-child2</code></pre><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><blockquote>
<p>在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br>区块是可以嵌套的</p>
</blockquote>
<pre><code>&gt; MarkDown

&gt;&gt; MarkDown</code></pre><p>区块于列表结合</p>
<blockquote>
<p>1.区块中使用列表<br>2.列表中使用区块</p>
</blockquote>
<pre><code>&gt; 区块中使用列表
&gt; 1. 有序
&gt; + 无序
&gt; 2. 有序
&gt; - 无序

1. 列表中使用区块
    &gt; 区块内容
    &gt;&gt; 区块内容
2. 列表中使用区块</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code>[链接名称](链接地址)
或者
&lt;链接地址&gt;

// 例：
[百度](www.baidu.com)
&lt;www.baidu.com&gt;</code></pre><h2 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h2><blockquote>
<p>链接也可以用变量来代替，文档末尾附带变量地址</p>
</blockquote>
<pre><code>百度[百度][1]
教育宝[教育宝][jyb]

[1]:www.baidu.con
[jyb]:https://www.jiaoyubao.cn/</code></pre><p><a href="www.baidu.con">百度</a></p>
<h1 id="引用本地图片"><a href="#引用本地图片" class="headerlink" title="引用本地图片"></a>引用本地图片</h1><blockquote>
<p>在hexo中把图片放在与博客同名的文件夹中，然后只用 <code>![图片描述](图片文件名)</code>就可以引用了。</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2019/10/23/blog/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p><a href="https://www.luogu.org/problem/P1495" target="_blank" rel="noopener">相关题面</a></p>
<h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><pre><code>int intchina(int r)
{
int Mi,x,y,d,ans=0;M=1;
for(int i=1;i&lt;=r;i++) M*=m[i];
for(int i=1;i&lt;=r;i++){
    M[i]=M/m[i];
    exgcd(Mi,m[i],d,x,y);
    ans=(ans+Mi*x*a[i])%M;
}
return (ans+M)%M; //正解
}</code></pre><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">相关题面</a></p>
<h2 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h2><pre><code>ll exgcd(ll a,ll b,ll &amp;x1, ll &amp;y1)
{
    if(!b)
    {
        x1=1;
        y1=0;
        return a;
    }
    ans=exgcd(b,a%b,x1,y1);
    ll t=x1;  //交换逆向求解
    x1=y1;
    y1=t-a/b*y1;
    return ans;
}</code></pre><ol>
<li>xa/d-yb/d=A/d这个方程就是扩展欧几里得exgcd(a,b,x,y)（忽略y前的负号），这样可以解出x，此时的x不是最优解，还要转换，即((x*(A/d))%(b/d)+(b/d))%(b/d)【求最小解的式子，不理解先背下来】。d是模。</li>
<li>当x不是最小正数解时，写成 x = (x % b + b) % b;循环至为正；</li>
</ol>
<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<p>————未学待补————</p>
</blockquote>
<hr>
<h1 id="二次剩余CipollaCipolla"><a href="#二次剩余CipollaCipolla" class="headerlink" title="二次剩余CipollaCipolla"></a>二次剩余CipollaCipolla</h1><p><a href="https://www.cnblogs.com/bztMinamoto/p/10664973.html" target="_blank" rel="noopener">学习资料1</a><br><a href="https://www.luogu.org/blog/oieremtkotori/2-0v0" target="_blank" rel="noopener">学习资料2</a></p>
<blockquote>
<p>————未学待补————</p>
</blockquote>
<hr>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>欧拉函数是小于x的整数中与x互质的数的个数，一般用φ(x)表示。特殊的，φ(1)=1。</p>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>先介绍一下什么是积性函数，后面将会用到。若当m与n互质时，f(m∗n)=f(m)∗f(n)，那么f是积性函数。若对任意正整数，都有f(m<em>n)=f(m)</em>f(n)成立，则f是完全积性函数。</p>
<p>##性质</p>
<ol>
<li>对于质数p,它的欧拉函数等于p-1.</li>
<li>若p为质数，n=p的k次方，则欧拉函数等于p^k-p^(k-1).比如说n的k次方分解质数只有p，则(p^k)*(1-1/p);</li>
<li>欧拉函数是积性函数，但不是完全积性函数。若m,n互质。则φ(m∗n)=φ(m)∗φ(n).特殊的，当m=2，n为奇数时，φ(2*n)=φ(n)。</li>
<li>当n&gt;2时，φ(n)是偶数.</li>
<li>小于n的数中,与n互质的数的总和为：φ(n)*n/2(n&gt;1);</li>
<li>n的因数的欧拉函数（包括1和它自己）的欧拉函数之和等于n。</li>
<li></li>
</ol>
<pre><code>  public static long ask(long m){//查单个欧拉函数
          long ans=m;
          for (long i =2; i*i&lt;=m; i++) {
              if(m%i==0){
                  ans=ans/i*(i-1);
                  while(m%i==0)m/=i;
              }
          }
          if(m&gt;1)ans=ans/m*(m-1);
          return ans;
      }

  public static void euler(int n) {//求一堆
    phi[1]=1;//特判
    for (int i =2; i &lt;=n; i++) {
        if(!flag[i]) {//判断是不是质数
            prime[++cent]=i;
            phi[i]=i-1;
        }
        for (int j =1; j&lt;=cent&amp;&amp;prime[j]*i&lt;=n; j++) {//欧拉筛
            flag[i*prime[j]]=true;//标记非质数
            if(i%prime[j]==0) {
                phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子
                break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次
            }else {
                phi[i*prime[j]]=phi[i]*phi[prime[j]];//积性函数
            }
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>伟大尝试</title>
    <url>/2019/10/23/%E4%BC%9F%E5%A4%A7%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>开始新的篇章<br>欢迎来到我的世界</p>
</blockquote>
<h1 id="阿瓦达"><a href="#阿瓦达" class="headerlink" title="阿瓦达"></a>阿瓦达</h1><h2 id="瓦大的有读"><a href="#瓦大的有读" class="headerlink" title="瓦大的有读"></a><em>瓦大的有读</em></h2><hr>
<h2 id="沃兹"><a href="#沃兹" class="headerlink" title="沃兹"></a><u>沃兹</u></h2><ol>
<li>awdawd</li>
<li>12321</li>
</ol>
<hr>
<ul>
<li>awdaw<blockquote>
<p>adawd</p>
<blockquote>
<p>awdawdwad</p>
<blockquote>
<p>awdawd</p>
<blockquote>
<p>dawdwadaw</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>有序</li>
</ol>
<ul>
<li>无序</li>
</ul>
<ol start="2">
<li>有序</li>
</ol>
<ul>
<li>无序</li>
</ul>
</blockquote>
<ol>
<li>列表中使用区块<blockquote>
<p>区块内容</p>
<blockquote>
<p>区块内容</p>
</blockquote>
</blockquote>
</li>
<li>列表中使用区块</li>
</ol>
<p><a href="www.baidu.com">百度</a><br>| awdaw | 啊达瓦 |</p>
<p><del>ad</del></p>
]]></content>
      <categories>
        <category>废话</category>
      </categories>
      <tags>
        <tag>废话</tag>
      </tags>
  </entry>
</search>
